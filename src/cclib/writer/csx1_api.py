#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Jan 21 11:41:41 2015 by generateDS.py version 2.12e.
#
# Command line options:
#   ('--namespacedef', 'xmlns:cs=http://chemicalsemantics.com/csx xmlns:dcterms=http:/purl.org/dc/terms/')
#   ('-o', 'csx1_api.py')
#   ('-s', 'csx1_sub.py')
#
# Command line arguments:
#   csx1.xsd
#
# Command line:
#   /usr/local/bin/generateDS.py --namespacedef="xmlns:cs=http://chemicalsemantics.com/csx xmlns:dcterms=http:/purl.org/dc/terms/" -o "csx1_api.py" -s "csx1_sub.py" csx1.xsd
#
# Current working directory (os.getcwd()):
#   CSX_v1
#

import sys
import getopt
import re as re_
import base64
import datetime as datetime_

etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class csType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, localFile=None, molecularPublication=None, molecularSystem=None, molecularCalculation=None):
        self.original_tagname_ = None
        self.version = _cast(None, version)
        self.localFile = _cast(None, localFile)
        self.molecularPublication = molecularPublication
        self.molecularSystem = molecularSystem
        self.molecularCalculation = molecularCalculation
    def factory(*args_, **kwargs_):
        if csType.subclass:
            return csType.subclass(*args_, **kwargs_)
        else:
            return csType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_molecularPublication(self): return self.molecularPublication
    def set_molecularPublication(self, molecularPublication): self.molecularPublication = molecularPublication
    def get_molecularSystem(self): return self.molecularSystem
    def set_molecularSystem(self, molecularSystem): self.molecularSystem = molecularSystem
    def get_molecularCalculation(self): return self.molecularCalculation
    def set_molecularCalculation(self, molecularCalculation): self.molecularCalculation = molecularCalculation
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_localFile(self): return self.localFile
    def set_localFile(self, localFile): self.localFile = localFile
    def hasContent_(self):
        if (
            self.molecularPublication is not None or
            self.molecularSystem is not None or
            self.molecularCalculation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='chemicalSemantics', namespacedef_='xmlns:cs="http://chemicalsemantics.com/csx"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='csType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='csType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='csType'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.localFile is not None and 'localFile' not in already_processed:
            already_processed.add('localFile')
            outfile.write(' localFile=%s' % (self.gds_format_string(quote_attrib(self.localFile).encode(ExternalEncoding), input_name='localFile'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='csType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.molecularPublication is not None:
            self.molecularPublication.export(outfile, level, namespace_, name_='molecularPublication', pretty_print=pretty_print)
        if self.molecularSystem is not None:
            self.molecularSystem.export(outfile, level, namespace_, name_='molecularSystem', pretty_print=pretty_print)
        if self.molecularCalculation is not None:
            self.molecularCalculation.export(outfile, level, namespace_, name_='molecularCalculation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='csType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.localFile is not None and 'localFile' not in already_processed:
            already_processed.add('localFile')
            showIndent(outfile, level)
            outfile.write('localFile="%s",\n' % (self.localFile,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.molecularPublication is not None:
            showIndent(outfile, level)
            outfile.write('molecularPublication=model_.mpType(\n')
            self.molecularPublication.exportLiteral(outfile, level, name_='molecularPublication')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.molecularSystem is not None:
            showIndent(outfile, level)
            outfile.write('molecularSystem=model_.msType(\n')
            self.molecularSystem.exportLiteral(outfile, level, name_='molecularSystem')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.molecularCalculation is not None:
            showIndent(outfile, level)
            outfile.write('molecularCalculation=model_.mcType(\n')
            self.molecularCalculation.exportLiteral(outfile, level, name_='molecularCalculation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('localFile', node)
        if value is not None and 'localFile' not in already_processed:
            already_processed.add('localFile')
            self.localFile = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'molecularPublication':
            obj_ = mpType.factory()
            obj_.build(child_)
            self.molecularPublication = obj_
            obj_.original_tagname_ = 'molecularPublication'
        elif nodeName_ == 'molecularSystem':
            obj_ = msType.factory()
            obj_.build(child_)
            self.molecularSystem = obj_
            obj_.original_tagname_ = 'molecularSystem'
        elif nodeName_ == 'molecularCalculation':
            obj_ = mcType.factory()
            obj_.build(child_)
            self.molecularCalculation = obj_
            obj_.original_tagname_ = 'molecularCalculation'
# end class csType


class mpType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, title=None, abstract=None, publisher=None, author=None, sourcePackage=None, tags=None, status=None, visibility=None, category=None, key=None):
        self.original_tagname_ = None
        self.title = title
        self.abstract = abstract
        self.publisher = publisher
        if author is None:
            self.author = []
        else:
            self.author = author
        self.sourcePackage = sourcePackage
        self.tags = tags
        self.status = status
        self.visibility = visibility
        self.category = category
        self.key = key
    def factory(*args_, **kwargs_):
        if mpType.subclass:
            return mpType.subclass(*args_, **kwargs_)
        else:
            return mpType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_abstract(self): return self.abstract
    def set_abstract(self, abstract): self.abstract = abstract
    def get_publisher(self): return self.publisher
    def set_publisher(self, publisher): self.publisher = publisher
    def get_author(self): return self.author
    def set_author(self, author): self.author = author
    def add_author(self, value): self.author.append(value)
    def insert_author_at(self, index, value): self.author.insert(index, value)
    def replace_author_at(self, index, value): self.author[index] = value
    def get_sourcePackage(self): return self.sourcePackage
    def set_sourcePackage(self, sourcePackage): self.sourcePackage = sourcePackage
    def get_tags(self): return self.tags
    def set_tags(self, tags): self.tags = tags
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_visibility(self): return self.visibility
    def set_visibility(self, visibility): self.visibility = visibility
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def hasContent_(self):
        if (
            self.title is not None or
            self.abstract is not None or
            self.publisher is not None or
            self.author or
            self.sourcePackage is not None or
            self.tags is not None or
            self.status is not None or
            self.visibility is not None or
            self.category is not None or
            self.key is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='mpType', namespacedef_='xmlns:cs="http://chemicalsemantics.com/csx" xmlns:dcterms="http://purl.org/dc/terms/" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mpType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='mpType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='mpType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='mpType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
#           self.title.export(outfile, level, namespace_='dcterms:', name_='title', pretty_print=pretty_print)
            namespace1_='dcterms:'
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespace1_, self.gds_format_string(quote_xml(self.title).encode(ExternalEncoding), input_name='title'), namespace1_, eol_))
        if self.abstract is not None:
#           self.abstract.export(outfile, level, namespace_='dcterms:', name_='abstract', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sabstract>%s</%sabstract>%s' % (namespace1_, self.gds_format_string(quote_xml(self.abstract).encode(ExternalEncoding), input_name='abstract'), namespace1_, eol_))
        if self.publisher is not None:
#           self.publisher.export(outfile, level, namespace_='dcterms:', name_='publisher', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spublisher>%s</%spublisher>%s' % (namespace1_, self.gds_format_string(quote_xml(self.publisher).encode(ExternalEncoding), input_name='publisher'), namespace1_, eol_))
        for author_ in self.author:
            author_.export(outfile, level, namespace_, name_='author', pretty_print=pretty_print)
        if self.sourcePackage is not None:
            self.sourcePackage.export(outfile, level, namespace_, name_='sourcePackage', pretty_print=pretty_print)
        if self.tags is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stags>%s</%stags>%s' % (namespace_, self.gds_format_string(quote_xml(self.tags).encode(ExternalEncoding), input_name='tags'), namespace_, eol_))
        if self.status is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstatus>%s</%sstatus>%s' % (namespace_, self.gds_format_string(quote_xml(self.status).encode(ExternalEncoding), input_name='status'), namespace_, eol_))
        if self.visibility is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svisibility>%s</%svisibility>%s' % (namespace_, self.gds_format_string(quote_xml(self.visibility).encode(ExternalEncoding), input_name='visibility'), namespace_, eol_))
        if self.category is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scategory>%s</%scategory>%s' % (namespace_, self.gds_format_string(quote_xml(self.category).encode(ExternalEncoding), input_name='category'), namespace_, eol_))
        if self.key is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skey>%s</%skey>%s' % (namespace_, self.gds_format_string(quote_xml(self.key).encode(ExternalEncoding), input_name='key'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='mpType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.title is not None:
            showIndent(outfile, level)
            outfile.write('title=model_.title(\n')
            self.title.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.abstract is not None:
            showIndent(outfile, level)
            outfile.write('abstract=model_.abstract(\n')
            self.abstract.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.publisher is not None:
            showIndent(outfile, level)
            outfile.write('publisher=model_.publisher(\n')
            self.publisher.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('author=[\n')
        level += 1
        for author_ in self.author:
            showIndent(outfile, level)
            outfile.write('model_.authorType(\n')
            author_.exportLiteral(outfile, level, name_='authorType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.sourcePackage is not None:
            showIndent(outfile, level)
            outfile.write('sourcePackage=model_.sourcePackageType(\n')
            self.sourcePackage.exportLiteral(outfile, level, name_='sourcePackage')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.tags is not None:
            showIndent(outfile, level)
            outfile.write('tags=%s,\n' % quote_python(self.tags).encode(ExternalEncoding))
        if self.status is not None:
            showIndent(outfile, level)
            outfile.write('status=%s,\n' % quote_python(self.status).encode(ExternalEncoding))
        if self.visibility is not None:
            showIndent(outfile, level)
            outfile.write('visibility=%s,\n' % quote_python(self.visibility).encode(ExternalEncoding))
        if self.category is not None:
            showIndent(outfile, level)
            outfile.write('category=%s,\n' % quote_python(self.category).encode(ExternalEncoding))
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key=%s,\n' % quote_python(self.key).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            obj_ = title.factory()
            obj_.build(child_)
            self.title = obj_
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'title':
            obj_ = title.factory()
            obj_.build(child_)
            self.title = obj_
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'alternative':
            obj_ = alternative.factory()
            obj_.build(child_)
            self.alternative = obj_
            obj_.original_tagname_ = 'alternative'
        elif nodeName_ == 'abstract':
            obj_ = abstract.factory()
            obj_.build(child_)
            self.abstract = obj_
            obj_.original_tagname_ = 'abstract'
        elif nodeName_ == 'publisher':
            obj_ = publisher.factory()
            obj_.build(child_)
            self.publisher = obj_
            obj_.original_tagname_ = 'publisher'
        elif nodeName_ == 'publisher':
            obj_ = publisher.factory()
            obj_.build(child_)
            self.publisher = obj_
            obj_.original_tagname_ = 'publisher'
        elif nodeName_ == 'author':
            obj_ = authorType.factory()
            obj_.build(child_)
            self.author.append(obj_)
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'sourcePackage':
            obj_ = sourcePackageType.factory()
            obj_.build(child_)
            self.sourcePackage = obj_
            obj_.original_tagname_ = 'sourcePackage'
        elif nodeName_ == 'tags':
            tags_ = child_.text
            tags_ = self.gds_validate_string(tags_, node, 'tags')
            self.tags = tags_
        elif nodeName_ == 'status':
            status_ = child_.text
            status_ = self.gds_validate_string(status_, node, 'status')
            self.status = status_
        elif nodeName_ == 'visibility':
            visibility_ = child_.text
            visibility_ = self.gds_validate_string(visibility_, node, 'visibility')
            self.visibility = visibility_
        elif nodeName_ == 'category':
            category_ = child_.text
            category_ = self.gds_validate_string(category_, node, 'category')
            self.category = category_
        elif nodeName_ == 'key':
            key_ = child_.text
            key_ = self.gds_validate_string(key_, node, 'key')
            self.key = key_
# end class mpType


class authorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, creator=None, organization=None, email=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.creator = creator
        self.organization = organization
        self.email = email
    def factory(*args_, **kwargs_):
        if authorType.subclass:
            return authorType.subclass(*args_, **kwargs_)
        else:
            return authorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creator(self): return self.creator
    def set_creator(self, creator): self.creator = creator
    def get_organization(self): return self.organization
    def set_organization(self, organization): self.organization = organization
    def get_email(self): return self.email
    def set_email(self, email): self.email = email
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def validate_emailType(self, value):
        # Validate type emailType, a restriction on xs:string.
        pass
    def validate_authortypeType(self, value):
        # Validate type authortypeType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.creator is not None or
            self.organization is not None or
            self.email is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='authorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='authorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='authorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='authorType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='authorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.creator is not None:
#           self.creator.export(outfile, level, namespace_='dcterms:', name_='creator', pretty_print=pretty_print)
            namespace1_='dcterms:'
            showIndent(outfile, level, pretty_print)
            outfile.write('<%screator>%s</%screator>%s' % (namespace1_, self.gds_format_string(quote_xml(self.creator).encode(ExternalEncoding), input_name='creator'), namespace1_, eol_))
        if self.organization is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorganization>%s</%sorganization>%s' % (namespace_, self.gds_format_string(quote_xml(self.organization).encode(ExternalEncoding), input_name='organization'), namespace_, eol_))
        if self.email is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespace_, self.gds_format_string(quote_xml(self.email).encode(ExternalEncoding), input_name='email'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='authorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.creator is not None:
            showIndent(outfile, level)
            outfile.write('creator=model_.creator(\n')
            self.creator.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.organization is not None:
            showIndent(outfile, level)
            outfile.write('organization=%s,\n' % quote_python(self.organization).encode(ExternalEncoding))
        if self.email is not None:
            showIndent(outfile, level)
            outfile.write('email=%s,\n' % quote_python(self.email).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_authortypeType(self.type_)    # validate type authortypeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'creator':
            obj_ = creator.factory()
            obj_.build(child_)
            self.creator = obj_
            obj_.original_tagname_ = 'creator'
        elif nodeName_ == 'creator':
            obj_ = creator.factory()
            obj_.build(child_)
            self.creator = obj_
            obj_.original_tagname_ = 'creator'
        elif nodeName_ == 'organization':
            organization_ = child_.text
            organization_ = self.gds_validate_string(organization_, node, 'organization')
            self.organization = organization_
        elif nodeName_ == 'email':
            email_ = child_.text
            email_ = self.gds_validate_string(email_, node, 'email')
            self.email = email_
            self.validate_emailType(self.email)    # validate type emailType
# end class authorType


class sourcePackageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, version=None, input=None, output=None):
        self.original_tagname_ = None
        self.name = name
        self.version = version
        self.input = input
        self.output = output
    def factory(*args_, **kwargs_):
        if sourcePackageType.subclass:
            return sourcePackageType.subclass(*args_, **kwargs_)
        else:
            return sourcePackageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_input(self): return self.input
    def set_input(self, input): self.input = input
    def get_output(self): return self.output
    def set_output(self, output): self.output = output
    def hasContent_(self):
        if (
            self.name is not None or
            self.version is not None or
            self.input is not None or
            self.output is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='sourcePackageType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sourcePackageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='sourcePackageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='sourcePackageType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='sourcePackageType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespace_, self.gds_format_string(quote_xml(self.version).encode(ExternalEncoding), input_name='version'), namespace_, eol_))
        if self.input is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinput>%s</%sinput>%s' % (namespace_, self.gds_format_string(quote_xml(self.input).encode(ExternalEncoding), input_name='input'), namespace_, eol_))
        if self.output is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soutput>%s</%soutput>%s' % (namespace_, self.gds_format_string(quote_xml(self.output).encode(ExternalEncoding), input_name='output'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='sourcePackageType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version=%s,\n' % quote_python(self.version).encode(ExternalEncoding))
        if self.input is not None:
            showIndent(outfile, level)
            outfile.write('input=%s,\n' % quote_python(self.input).encode(ExternalEncoding))
        if self.output is not None:
            showIndent(outfile, level)
            outfile.write('output=%s,\n' % quote_python(self.output).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'version':
            version_ = child_.text
            version_ = self.gds_validate_string(version_, node, 'version')
            self.version = version_
        elif nodeName_ == 'input':
            input_ = child_.text
            input_ = self.gds_validate_string(input_, node, 'input')
            self.input = input_
        elif nodeName_ == 'output':
            output_ = child_.text
            output_ = self.gds_validate_string(output_, node, 'output')
            self.output = output_
# end class sourcePackageType


class msType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, systemTemperature=None, systemCharge=None, systemMultiplicity=None, molecule=None, residue=None, group=None, atom=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.systemTemperature = systemTemperature
        self.systemCharge = systemCharge
        self.systemMultiplicity = systemMultiplicity
        if molecule is None:
            self.molecule = []
        else:
            self.molecule = molecule
        if residue is None:
            self.residue = []
        else:
            self.residue = residue
        if group is None:
            self.group = []
        else:
            self.group = group
        if atom is None:
            self.atom = []
        else:
            self.atom = atom
    def factory(*args_, **kwargs_):
        if msType.subclass:
            return msType.subclass(*args_, **kwargs_)
        else:
            return msType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_systemTemperature(self): return self.systemTemperature
    def set_systemTemperature(self, systemTemperature): self.systemTemperature = systemTemperature
    def get_systemCharge(self): return self.systemCharge
    def set_systemCharge(self, systemCharge): self.systemCharge = systemCharge
    def get_systemMultiplicity(self): return self.systemMultiplicity
    def set_systemMultiplicity(self, systemMultiplicity): self.systemMultiplicity = systemMultiplicity
    def get_molecule(self): return self.molecule
    def set_molecule(self, molecule): self.molecule = molecule
    def add_molecule(self, value): self.molecule.append(value)
    def insert_molecule_at(self, index, value): self.molecule.insert(index, value)
    def replace_molecule_at(self, index, value): self.molecule[index] = value
    def get_residue(self): return self.residue
    def set_residue(self, residue): self.residue = residue
    def add_residue(self, value): self.residue.append(value)
    def insert_residue_at(self, index, value): self.residue.insert(index, value)
    def replace_residue_at(self, index, value): self.residue[index] = value
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def add_group(self, value): self.group.append(value)
    def insert_group_at(self, index, value): self.group.insert(index, value)
    def replace_group_at(self, index, value): self.group[index] = value
    def get_atom(self): return self.atom
    def set_atom(self, atom): self.atom = atom
    def add_atom(self, value): self.atom.append(value)
    def insert_atom_at(self, index, value): self.atom.insert(index, value)
    def replace_atom_at(self, index, value): self.atom[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.systemTemperature is not None or
            self.systemCharge is not None or
            self.systemMultiplicity is not None or
            self.molecule or
            self.residue or
            self.group or
            self.atom
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='msType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='msType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='msType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='msType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='msType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.systemTemperature is not None:
            self.systemTemperature.export(outfile, level, namespace_, name_='systemTemperature', pretty_print=pretty_print)
        if self.systemCharge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssystemCharge>%s</%ssystemCharge>%s' % (namespace_, self.gds_format_integer(self.systemCharge, input_name='systemCharge'), namespace_, eol_))
        if self.systemMultiplicity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssystemMultiplicity>%s</%ssystemMultiplicity>%s' % (namespace_, self.gds_format_integer(self.systemMultiplicity, input_name='systemMultiplicity'), namespace_, eol_))
        for molecule_ in self.molecule:
            molecule_.export(outfile, level, namespace_, name_='molecule', pretty_print=pretty_print)
        for residue_ in self.residue:
            residue_.export(outfile, level, namespace_, name_='residue', pretty_print=pretty_print)
        for group_ in self.group:
            group_.export(outfile, level, namespace_, name_='group', pretty_print=pretty_print)
        for atom_ in self.atom:
            atom_.export(outfile, level, namespace_, name_='atom', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='msType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.systemTemperature is not None:
            showIndent(outfile, level)
            outfile.write('systemTemperature=model_.dataWithUnitsType(\n')
            self.systemTemperature.exportLiteral(outfile, level, name_='systemTemperature')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.systemCharge is not None:
            showIndent(outfile, level)
            outfile.write('systemCharge=%d,\n' % self.systemCharge)
        if self.systemMultiplicity is not None:
            showIndent(outfile, level)
            outfile.write('systemMultiplicity=%d,\n' % self.systemMultiplicity)
        showIndent(outfile, level)
        outfile.write('molecule=[\n')
        level += 1
        for molecule_ in self.molecule:
            showIndent(outfile, level)
            outfile.write('model_.moleculeType(\n')
            molecule_.exportLiteral(outfile, level, name_='moleculeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('residue=[\n')
        level += 1
        for residue_ in self.residue:
            showIndent(outfile, level)
            outfile.write('model_.residueType(\n')
            residue_.exportLiteral(outfile, level, name_='residueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('model_.groupType(\n')
            group_.exportLiteral(outfile, level, name_='groupType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('atom=[\n')
        level += 1
        for atom_ in self.atom:
            showIndent(outfile, level)
            outfile.write('model_.atomType(\n')
            atom_.exportLiteral(outfile, level, name_='atomType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'systemTemperature':
            obj_ = dataWithUnitsType.factory()
            obj_.build(child_)
            self.systemTemperature = obj_
            obj_.original_tagname_ = 'systemTemperature'
        elif nodeName_ == 'systemCharge':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'systemCharge')
            self.systemCharge = ival_
        elif nodeName_ == 'systemMultiplicity':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'systemMultiplicity')
            self.systemMultiplicity = ival_
        elif nodeName_ == 'molecule':
            obj_ = moleculeType.factory()
            obj_.build(child_)
            self.molecule.append(obj_)
            obj_.original_tagname_ = 'molecule'
        elif nodeName_ == 'residue':
            obj_ = residueType.factory()
            obj_.build(child_)
            self.residue.append(obj_)
            obj_.original_tagname_ = 'residue'
        elif nodeName_ == 'group':
            obj_ = groupType.factory()
            obj_.build(child_)
            self.group.append(obj_)
            obj_.original_tagname_ = 'group'
        elif nodeName_ == 'atom':
            obj_ = atomType.factory()
            obj_.build(child_)
            self.atom.append(obj_)
            obj_.original_tagname_ = 'atom'
# end class msType


class moleculeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, atomCount=None, id=None, molSymmetry=None, inchiKey=None, residue=None, group=None, atom=None):
        self.original_tagname_ = None
        self.atomCount = _cast(int, atomCount)
        self.id = _cast(None, id)
        self.molSymmetry = _cast(None, molSymmetry)
        self.inchiKey = inchiKey
        if residue is None:
            self.residue = []
        else:
            self.residue = residue
        if group is None:
            self.group = []
        else:
            self.group = group
        if atom is None:
            self.atom = []
        else:
            self.atom = atom
    def factory(*args_, **kwargs_):
        if moleculeType.subclass:
            return moleculeType.subclass(*args_, **kwargs_)
        else:
            return moleculeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_inchiKey(self): return self.inchiKey
    def set_inchiKey(self, inchiKey): self.inchiKey = inchiKey
    def get_residue(self): return self.residue
    def set_residue(self, residue): self.residue = residue
    def add_residue(self, value): self.residue.append(value)
    def insert_residue_at(self, index, value): self.residue.insert(index, value)
    def replace_residue_at(self, index, value): self.residue[index] = value
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def add_group(self, value): self.group.append(value)
    def insert_group_at(self, index, value): self.group.insert(index, value)
    def replace_group_at(self, index, value): self.group[index] = value
    def get_atom(self): return self.atom
    def set_atom(self, atom): self.atom = atom
    def add_atom(self, value): self.atom.append(value)
    def insert_atom_at(self, index, value): self.atom.insert(index, value)
    def replace_atom_at(self, index, value): self.atom[index] = value
    def get_atomCount(self): return self.atomCount
    def set_atomCount(self, atomCount): self.atomCount = atomCount
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_molSymmetry(self): return self.molSymmetry
    def set_molSymmetry(self, molSymmetry): self.molSymmetry = molSymmetry
    def validate_inchiKeyType(self, value):
        # Validate type inchiKeyType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.inchiKey is not None or
            self.residue or
            self.group or
            self.atom
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='moleculeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='moleculeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='moleculeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='moleculeType'):
        if self.atomCount is not None and 'atomCount' not in already_processed:
            already_processed.add('atomCount')
            outfile.write(' atomCount="%s"' % self.gds_format_integer(self.atomCount, input_name='atomCount'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.molSymmetry is not None and 'molSymmetry' not in already_processed:
            already_processed.add('molSymmetry')
            outfile.write(' molSymmetry=%s' % (self.gds_format_string(quote_attrib(self.molSymmetry).encode(ExternalEncoding), input_name='molSymmetry'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='moleculeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.inchiKey is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinchiKey>%s</%sinchiKey>%s' % (namespace_, self.gds_format_string(quote_xml(self.inchiKey).encode(ExternalEncoding), input_name='inchiKey'), namespace_, eol_))
        for residue_ in self.residue:
            residue_.export(outfile, level, namespace_, name_='residue', pretty_print=pretty_print)
        for group_ in self.group:
            group_.export(outfile, level, namespace_, name_='group', pretty_print=pretty_print)
        for atom_ in self.atom:
            atom_.export(outfile, level, namespace_, name_='atom', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='moleculeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.atomCount is not None and 'atomCount' not in already_processed:
            already_processed.add('atomCount')
            showIndent(outfile, level)
            outfile.write('atomCount=%d,\n' % (self.atomCount,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.molSymmetry is not None and 'molSymmetry' not in already_processed:
            already_processed.add('molSymmetry')
            showIndent(outfile, level)
            outfile.write('molSymmetry="%s",\n' % (self.molSymmetry,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.inchiKey is not None:
            showIndent(outfile, level)
            outfile.write('inchiKey=%s,\n' % quote_python(self.inchiKey).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('residue=[\n')
        level += 1
        for residue_ in self.residue:
            showIndent(outfile, level)
            outfile.write('model_.residueType(\n')
            residue_.exportLiteral(outfile, level, name_='residueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('model_.groupType(\n')
            group_.exportLiteral(outfile, level, name_='groupType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('atom=[\n')
        level += 1
        for atom_ in self.atom:
            showIndent(outfile, level)
            outfile.write('model_.atomType(\n')
            atom_.exportLiteral(outfile, level, name_='atomType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('atomCount', node)
        if value is not None and 'atomCount' not in already_processed:
            already_processed.add('atomCount')
            try:
                self.atomCount = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.atomCount < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('molSymmetry', node)
        if value is not None and 'molSymmetry' not in already_processed:
            already_processed.add('molSymmetry')
            self.molSymmetry = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'inchiKey':
            inchiKey_ = child_.text
            inchiKey_ = self.gds_validate_string(inchiKey_, node, 'inchiKey')
            self.inchiKey = inchiKey_
            self.validate_inchiKeyType(self.inchiKey)    # validate type inchiKeyType
        elif nodeName_ == 'residue':
            obj_ = residueType.factory()
            obj_.build(child_)
            self.residue.append(obj_)
            obj_.original_tagname_ = 'residue'
        elif nodeName_ == 'group':
            obj_ = groupType.factory()
            obj_.build(child_)
            self.group.append(obj_)
            obj_.original_tagname_ = 'group'
        elif nodeName_ == 'atom':
            obj_ = atomType.factory()
            obj_.build(child_)
            self.atom.append(obj_)
            obj_.original_tagname_ = 'atom'
# end class moleculeType


class residueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, atomCount=None, id=None, resName=None, sequence=None, insertion=None, chain=None, secStruct=None, group=None, atom=None):
        self.original_tagname_ = None
        self.atomCount = _cast(int, atomCount)
        self.id = _cast(None, id)
        self.resName = resName
        self.sequence = sequence
        self.insertion = insertion
        self.chain = chain
        self.secStruct = secStruct
        if group is None:
            self.group = []
        else:
            self.group = group
        if atom is None:
            self.atom = []
        else:
            self.atom = atom
    def factory(*args_, **kwargs_):
        if residueType.subclass:
            return residueType.subclass(*args_, **kwargs_)
        else:
            return residueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resName(self): return self.resName
    def set_resName(self, resName): self.resName = resName
    def get_sequence(self): return self.sequence
    def set_sequence(self, sequence): self.sequence = sequence
    def get_insertion(self): return self.insertion
    def set_insertion(self, insertion): self.insertion = insertion
    def get_chain(self): return self.chain
    def set_chain(self, chain): self.chain = chain
    def get_secStruct(self): return self.secStruct
    def set_secStruct(self, secStruct): self.secStruct = secStruct
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def add_group(self, value): self.group.append(value)
    def insert_group_at(self, index, value): self.group.insert(index, value)
    def replace_group_at(self, index, value): self.group[index] = value
    def get_atom(self): return self.atom
    def set_atom(self, atom): self.atom = atom
    def add_atom(self, value): self.atom.append(value)
    def insert_atom_at(self, index, value): self.atom.insert(index, value)
    def replace_atom_at(self, index, value): self.atom[index] = value
    def get_atomCount(self): return self.atomCount
    def set_atomCount(self, atomCount): self.atomCount = atomCount
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.resName is not None or
            self.sequence is not None or
            self.insertion is not None or
            self.chain is not None or
            self.secStruct is not None or
            self.group or
            self.atom
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='residueType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='residueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='residueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='residueType'):
        if self.atomCount is not None and 'atomCount' not in already_processed:
            already_processed.add('atomCount')
            outfile.write(' atomCount="%s"' % self.gds_format_integer(self.atomCount, input_name='atomCount'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='residueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.resName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sresName>%s</%sresName>%s' % (namespace_, self.gds_format_string(quote_xml(self.resName).encode(ExternalEncoding), input_name='resName'), namespace_, eol_))
        if self.sequence is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssequence>%s</%ssequence>%s' % (namespace_, self.gds_format_string(quote_xml(self.sequence).encode(ExternalEncoding), input_name='sequence'), namespace_, eol_))
        if self.insertion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinsertion>%s</%sinsertion>%s' % (namespace_, self.gds_format_string(quote_xml(self.insertion).encode(ExternalEncoding), input_name='insertion'), namespace_, eol_))
        if self.chain is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schain>%s</%schain>%s' % (namespace_, self.gds_format_string(quote_xml(self.chain).encode(ExternalEncoding), input_name='chain'), namespace_, eol_))
        if self.secStruct is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssecStruct>%s</%ssecStruct>%s' % (namespace_, self.gds_format_string(quote_xml(self.secStruct).encode(ExternalEncoding), input_name='secStruct'), namespace_, eol_))
        for group_ in self.group:
            group_.export(outfile, level, namespace_, name_='group', pretty_print=pretty_print)
        for atom_ in self.atom:
            atom_.export(outfile, level, namespace_, name_='atom', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='residueType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.atomCount is not None and 'atomCount' not in already_processed:
            already_processed.add('atomCount')
            showIndent(outfile, level)
            outfile.write('atomCount=%d,\n' % (self.atomCount,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.resName is not None:
            showIndent(outfile, level)
            outfile.write('resName=%s,\n' % quote_python(self.resName).encode(ExternalEncoding))
        if self.sequence is not None:
            showIndent(outfile, level)
            outfile.write('sequence=%s,\n' % quote_python(self.sequence).encode(ExternalEncoding))
        if self.insertion is not None:
            showIndent(outfile, level)
            outfile.write('insertion=%s,\n' % quote_python(self.insertion).encode(ExternalEncoding))
        if self.chain is not None:
            showIndent(outfile, level)
            outfile.write('chain=%s,\n' % quote_python(self.chain).encode(ExternalEncoding))
        if self.secStruct is not None:
            showIndent(outfile, level)
            outfile.write('secStruct=%s,\n' % quote_python(self.secStruct).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('model_.groupType(\n')
            group_.exportLiteral(outfile, level, name_='groupType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('atom=[\n')
        level += 1
        for atom_ in self.atom:
            showIndent(outfile, level)
            outfile.write('model_.atomType(\n')
            atom_.exportLiteral(outfile, level, name_='atomType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('atomCount', node)
        if value is not None and 'atomCount' not in already_processed:
            already_processed.add('atomCount')
            try:
                self.atomCount = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.atomCount < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'resName':
            resName_ = child_.text
            resName_ = self.gds_validate_string(resName_, node, 'resName')
            self.resName = resName_
        elif nodeName_ == 'sequence':
            sequence_ = child_.text
            sequence_ = self.gds_validate_string(sequence_, node, 'sequence')
            self.sequence = sequence_
        elif nodeName_ == 'insertion':
            insertion_ = child_.text
            insertion_ = self.gds_validate_string(insertion_, node, 'insertion')
            self.insertion = insertion_
        elif nodeName_ == 'chain':
            chain_ = child_.text
            chain_ = self.gds_validate_string(chain_, node, 'chain')
            self.chain = chain_
        elif nodeName_ == 'secStruct':
            secStruct_ = child_.text
            secStruct_ = self.gds_validate_string(secStruct_, node, 'secStruct')
            self.secStruct = secStruct_
        elif nodeName_ == 'group':
            obj_ = groupType.factory()
            obj_.build(child_)
            self.group.append(obj_)
            obj_.original_tagname_ = 'group'
        elif nodeName_ == 'atom':
            obj_ = atomType.factory()
            obj_.build(child_)
            self.atom.append(obj_)
            obj_.original_tagname_ = 'atom'
# end class residueType


class groupType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, atomCount=None, id=None, groupName=None, atom=None):
        self.original_tagname_ = None
        self.atomCount = _cast(int, atomCount)
        self.id = _cast(None, id)
        self.groupName = groupName
        if atom is None:
            self.atom = []
        else:
            self.atom = atom
    def factory(*args_, **kwargs_):
        if groupType.subclass:
            return groupType.subclass(*args_, **kwargs_)
        else:
            return groupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_groupName(self): return self.groupName
    def set_groupName(self, groupName): self.groupName = groupName
    def get_atom(self): return self.atom
    def set_atom(self, atom): self.atom = atom
    def add_atom(self, value): self.atom.append(value)
    def insert_atom_at(self, index, value): self.atom.insert(index, value)
    def replace_atom_at(self, index, value): self.atom[index] = value
    def get_atomCount(self): return self.atomCount
    def set_atomCount(self, atomCount): self.atomCount = atomCount
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.groupName is not None or
            self.atom
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='groupType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='groupType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='groupType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='groupType'):
        if self.atomCount is not None and 'atomCount' not in already_processed:
            already_processed.add('atomCount')
            outfile.write(' atomCount="%s"' % self.gds_format_integer(self.atomCount, input_name='atomCount'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='groupType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.groupName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgroupName>%s</%sgroupName>%s' % (namespace_, self.gds_format_string(quote_xml(self.groupName).encode(ExternalEncoding), input_name='groupName'), namespace_, eol_))
        for atom_ in self.atom:
            atom_.export(outfile, level, namespace_, name_='atom', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='groupType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.atomCount is not None and 'atomCount' not in already_processed:
            already_processed.add('atomCount')
            showIndent(outfile, level)
            outfile.write('atomCount=%d,\n' % (self.atomCount,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.groupName is not None:
            showIndent(outfile, level)
            outfile.write('groupName=%s,\n' % quote_python(self.groupName).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('atom=[\n')
        level += 1
        for atom_ in self.atom:
            showIndent(outfile, level)
            outfile.write('model_.atomType(\n')
            atom_.exportLiteral(outfile, level, name_='atomType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('atomCount', node)
        if value is not None and 'atomCount' not in already_processed:
            already_processed.add('atomCount')
            try:
                self.atomCount = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.atomCount < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'groupName':
            groupName_ = child_.text
            groupName_ = self.gds_validate_string(groupName_, node, 'groupName')
            self.groupName = groupName_
        elif nodeName_ == 'atom':
            obj_ = atomType.factory()
            obj_.build(child_)
            self.atom.append(obj_)
            obj_.original_tagname_ = 'atom'
# end class groupType


class atomType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, elementSymbol=None, elementName=None, atomName=None, atomMass=None, atomType=None, formalAtomCharge=None, calculatedAtomCharge=None, chirality=None, xCoord3D=None, yCoord3D=None, zCoord3D=None, basisSet=None, coordination=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.elementSymbol = elementSymbol
        self.elementName = elementName
        self.atomName = atomName
        self.atomMass = atomMass
        self.atomType = atomType
        self.formalAtomCharge = formalAtomCharge
        self.calculatedAtomCharge = calculatedAtomCharge
        self.chirality = chirality
        self.xCoord3D = xCoord3D
        self.yCoord3D = yCoord3D
        self.zCoord3D = zCoord3D
        self.basisSet = basisSet
        self.coordination = coordination
    def factory(*args_, **kwargs_):
        if atomType.subclass:
            return atomType.subclass(*args_, **kwargs_)
        else:
            return atomType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_elementSymbol(self): return self.elementSymbol
    def set_elementSymbol(self, elementSymbol): self.elementSymbol = elementSymbol
    def get_elementName(self): return self.elementName
    def set_elementName(self, elementName): self.elementName = elementName
    def get_atomName(self): return self.atomName
    def set_atomName(self, atomName): self.atomName = atomName
    def get_atomMass(self): return self.atomMass
    def set_atomMass(self, atomMass): self.atomMass = atomMass
    def get_atomType(self): return self.atomType
    def set_atomType(self, atomType): self.atomType = atomType
    def get_formalAtomCharge(self): return self.formalAtomCharge
    def set_formalAtomCharge(self, formalAtomCharge): self.formalAtomCharge = formalAtomCharge
    def get_calculatedAtomCharge(self): return self.calculatedAtomCharge
    def set_calculatedAtomCharge(self, calculatedAtomCharge): self.calculatedAtomCharge = calculatedAtomCharge
    def get_chirality(self): return self.chirality
    def set_chirality(self, chirality): self.chirality = chirality
    def get_xCoord3D(self): return self.xCoord3D
    def set_xCoord3D(self, xCoord3D): self.xCoord3D = xCoord3D
    def get_yCoord3D(self): return self.yCoord3D
    def set_yCoord3D(self, yCoord3D): self.yCoord3D = yCoord3D
    def get_zCoord3D(self): return self.zCoord3D
    def set_zCoord3D(self, zCoord3D): self.zCoord3D = zCoord3D
    def get_basisSet(self): return self.basisSet
    def set_basisSet(self, basisSet): self.basisSet = basisSet
    def get_coordination(self): return self.coordination
    def set_coordination(self, coordination): self.coordination = coordination
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_elementSymbolType(self, value):
        # Validate type elementSymbolType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.elementSymbol is not None or
            self.elementName is not None or
            self.atomName is not None or
            self.atomMass is not None or
            self.atomType is not None or
            self.formalAtomCharge is not None or
            self.calculatedAtomCharge is not None or
            self.chirality is not None or
            self.xCoord3D is not None or
            self.yCoord3D is not None or
            self.zCoord3D is not None or
            self.basisSet is not None or
            self.coordination is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='atomType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='atomType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='atomType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='atomType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='atomType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.elementSymbol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%selementSymbol>%s</%selementSymbol>%s' % (namespace_, self.gds_format_string(quote_xml(self.elementSymbol).encode(ExternalEncoding), input_name='elementSymbol'), namespace_, eol_))
        if self.elementName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%selementName>%s</%selementName>%s' % (namespace_, self.gds_format_string(quote_xml(self.elementName).encode(ExternalEncoding), input_name='elementName'), namespace_, eol_))
        if self.atomName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%satomName>%s</%satomName>%s' % (namespace_, self.gds_format_string(quote_xml(self.atomName).encode(ExternalEncoding), input_name='atomName'), namespace_, eol_))
        if self.atomMass is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%satomMass>%s</%satomMass>%s' % (namespace_, self.gds_format_float(self.atomMass, input_name='atomMass'), namespace_, eol_))
        if self.atomType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%satomType>%s</%satomType>%s' % (namespace_, self.gds_format_string(quote_xml(self.atomType).encode(ExternalEncoding), input_name='atomType'), namespace_, eol_))
        if self.formalAtomCharge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sformalAtomCharge>%s</%sformalAtomCharge>%s' % (namespace_, self.gds_format_integer(self.formalAtomCharge, input_name='formalAtomCharge'), namespace_, eol_))
        if self.calculatedAtomCharge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scalculatedAtomCharge>%s</%scalculatedAtomCharge>%s' % (namespace_, self.gds_format_float(self.calculatedAtomCharge, input_name='calculatedAtomCharge'), namespace_, eol_))
        if self.chirality is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schirality>%s</%schirality>%s' % (namespace_, self.gds_format_string(quote_xml(self.chirality).encode(ExternalEncoding), input_name='chirality'), namespace_, eol_))
        if self.xCoord3D is not None:
            self.xCoord3D.export(outfile, level, namespace_, name_='xCoord3D', pretty_print=pretty_print)
        if self.yCoord3D is not None:
            self.yCoord3D.export(outfile, level, namespace_, name_='yCoord3D', pretty_print=pretty_print)
        if self.zCoord3D is not None:
            self.zCoord3D.export(outfile, level, namespace_, name_='zCoord3D', pretty_print=pretty_print)
        if self.basisSet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbasisSet>%s</%sbasisSet>%s' % (namespace_, self.gds_format_string(quote_xml(self.basisSet).encode(ExternalEncoding), input_name='basisSet'), namespace_, eol_))
        if self.coordination is not None:
            self.coordination.export(outfile, level, namespace_, name_='coordination', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='atomType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.elementSymbol is not None:
            showIndent(outfile, level)
            outfile.write('elementSymbol=%s,\n' % quote_python(self.elementSymbol).encode(ExternalEncoding))
        if self.elementName is not None:
            showIndent(outfile, level)
            outfile.write('elementName=%s,\n' % quote_python(self.elementName).encode(ExternalEncoding))
        if self.atomName is not None:
            showIndent(outfile, level)
            outfile.write('atomName=%s,\n' % quote_python(self.atomName).encode(ExternalEncoding))
        if self.atomMass is not None:
            showIndent(outfile, level)
            outfile.write('atomMass=%f,\n' % self.atomMass)
        if self.atomType is not None:
            showIndent(outfile, level)
            outfile.write('atomType=%s,\n' % quote_python(self.atomType).encode(ExternalEncoding))
        if self.formalAtomCharge is not None:
            showIndent(outfile, level)
            outfile.write('formalAtomCharge=%d,\n' % self.formalAtomCharge)
        if self.calculatedAtomCharge is not None:
            showIndent(outfile, level)
            outfile.write('calculatedAtomCharge=%f,\n' % self.calculatedAtomCharge)
        if self.chirality is not None:
            showIndent(outfile, level)
            outfile.write('chirality=%s,\n' % quote_python(self.chirality).encode(ExternalEncoding))
        if self.xCoord3D is not None:
            showIndent(outfile, level)
            outfile.write('xCoord3D=model_.dataWithUnitsType(\n')
            self.xCoord3D.exportLiteral(outfile, level, name_='xCoord3D')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.yCoord3D is not None:
            showIndent(outfile, level)
            outfile.write('yCoord3D=model_.dataWithUnitsType(\n')
            self.yCoord3D.exportLiteral(outfile, level, name_='yCoord3D')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.zCoord3D is not None:
            showIndent(outfile, level)
            outfile.write('zCoord3D=model_.dataWithUnitsType(\n')
            self.zCoord3D.exportLiteral(outfile, level, name_='zCoord3D')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.basisSet is not None:
            showIndent(outfile, level)
            outfile.write('basisSet=%s,\n' % quote_python(self.basisSet).encode(ExternalEncoding))
        if self.coordination is not None:
            showIndent(outfile, level)
            outfile.write('coordination=model_.coordinationType(\n')
            self.coordination.exportLiteral(outfile, level, name_='coordination')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'elementSymbol':
            elementSymbol_ = child_.text
            elementSymbol_ = self.gds_validate_string(elementSymbol_, node, 'elementSymbol')
            self.elementSymbol = elementSymbol_
            self.validate_elementSymbolType(self.elementSymbol)    # validate type elementSymbolType
        elif nodeName_ == 'elementName':
            elementName_ = child_.text
            elementName_ = self.gds_validate_string(elementName_, node, 'elementName')
            self.elementName = elementName_
        elif nodeName_ == 'atomName':
            atomName_ = child_.text
            atomName_ = self.gds_validate_string(atomName_, node, 'atomName')
            self.atomName = atomName_
        elif nodeName_ == 'atomMass':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'atomMass')
            self.atomMass = fval_
        elif nodeName_ == 'atomType':
            atomType_ = child_.text
            atomType_ = self.gds_validate_string(atomType_, node, 'atomType')
            self.atomType = atomType_
        elif nodeName_ == 'formalAtomCharge':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'formalAtomCharge')
            self.formalAtomCharge = ival_
        elif nodeName_ == 'calculatedAtomCharge':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'calculatedAtomCharge')
            self.calculatedAtomCharge = fval_
        elif nodeName_ == 'chirality':
            chirality_ = child_.text
            chirality_ = self.gds_validate_string(chirality_, node, 'chirality')
            self.chirality = chirality_
        elif nodeName_ == 'xCoord3D':
            obj_ = dataWithUnitsType.factory()
            obj_.build(child_)
            self.xCoord3D = obj_
            obj_.original_tagname_ = 'xCoord3D'
        elif nodeName_ == 'yCoord3D':
            obj_ = dataWithUnitsType.factory()
            obj_.build(child_)
            self.yCoord3D = obj_
            obj_.original_tagname_ = 'yCoord3D'
        elif nodeName_ == 'zCoord3D':
            obj_ = dataWithUnitsType.factory()
            obj_.build(child_)
            self.zCoord3D = obj_
            obj_.original_tagname_ = 'zCoord3D'
        elif nodeName_ == 'basisSet':
            basisSet_ = child_.text
            basisSet_ = self.gds_validate_string(basisSet_, node, 'basisSet')
            self.basisSet = basisSet_
        elif nodeName_ == 'coordination':
            obj_ = coordinationType.factory()
            obj_.build(child_)
            self.coordination = obj_
            obj_.original_tagname_ = 'coordination'
# end class atomType


class coordinationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, bondCount=None, bond=None):
        self.original_tagname_ = None
        self.bondCount = _cast(int, bondCount)
        if bond is None:
            self.bond = []
        else:
            self.bond = bond
    def factory(*args_, **kwargs_):
        if coordinationType.subclass:
            return coordinationType.subclass(*args_, **kwargs_)
        else:
            return coordinationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bond(self): return self.bond
    def set_bond(self, bond): self.bond = bond
    def add_bond(self, value): self.bond.append(value)
    def insert_bond_at(self, index, value): self.bond.insert(index, value)
    def replace_bond_at(self, index, value): self.bond[index] = value
    def get_bondCount(self): return self.bondCount
    def set_bondCount(self, bondCount): self.bondCount = bondCount
    def hasContent_(self):
        if (
            self.bond
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='coordinationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='coordinationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='coordinationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='coordinationType'):
        if self.bondCount is not None and 'bondCount' not in already_processed:
            already_processed.add('bondCount')
            outfile.write(' bondCount="%s"' % self.gds_format_integer(self.bondCount, input_name='bondCount'))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='coordinationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for bond_ in self.bond:
            bond_.export(outfile, level, namespace_, name_='bond', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='coordinationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.bondCount is not None and 'bondCount' not in already_processed:
            already_processed.add('bondCount')
            showIndent(outfile, level)
            outfile.write('bondCount=%d,\n' % (self.bondCount,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('bond=[\n')
        level += 1
        for bond_ in self.bond:
            showIndent(outfile, level)
            outfile.write('model_.bondType(\n')
            bond_.exportLiteral(outfile, level, name_='bondType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('bondCount', node)
        if value is not None and 'bondCount' not in already_processed:
            already_processed.add('bondCount')
            try:
                self.bondCount = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.bondCount < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'bond':
            obj_ = bondType.factory()
            obj_.build(child_)
            self.bond.append(obj_)
            obj_.original_tagname_ = 'bond'
# end class coordinationType


class bondType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id2=None, id1=None, valueOf_=None):
        self.original_tagname_ = None
        self.id2 = _cast(None, id2)
        self.id1 = _cast(None, id1)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if bondType.subclass:
            return bondType.subclass(*args_, **kwargs_)
        else:
            return bondType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id2(self): return self.id2
    def set_id2(self, id2): self.id2 = id2
    def get_id1(self): return self.id1
    def set_id1(self, id1): self.id1 = id1
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='bondType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='bondType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='bondType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='bondType'):
        if self.id2 is not None and 'id2' not in already_processed:
            already_processed.add('id2')
            outfile.write(' id2=%s' % (self.gds_format_string(quote_attrib(self.id2).encode(ExternalEncoding), input_name='id2'), ))
        if self.id1 is not None and 'id1' not in already_processed:
            already_processed.add('id1')
            outfile.write(' id1=%s' % (self.gds_format_string(quote_attrib(self.id1).encode(ExternalEncoding), input_name='id1'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='bondType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='bondType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id2 is not None and 'id2' not in already_processed:
            already_processed.add('id2')
            showIndent(outfile, level)
            outfile.write('id2="%s",\n' % (self.id2,))
        if self.id1 is not None and 'id1' not in already_processed:
            already_processed.add('id1')
            showIndent(outfile, level)
            outfile.write('id1="%s",\n' % (self.id1,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id2', node)
        if value is not None and 'id2' not in already_processed:
            already_processed.add('id2')
            self.id2 = value
        value = find_attr_value_('id1', node)
        if value is not None and 'id1' not in already_processed:
            already_processed.add('id1')
            self.id1 = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class bondType


class mcType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, quantumMechanics=None, molecularMechanics=None, multiscale=None, statisticalMechanics=None):
        self.original_tagname_ = None
        self.quantumMechanics = quantumMechanics
        self.molecularMechanics = molecularMechanics
        self.multiscale = multiscale
        self.statisticalMechanics = statisticalMechanics
    def factory(*args_, **kwargs_):
        if mcType.subclass:
            return mcType.subclass(*args_, **kwargs_)
        else:
            return mcType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quantumMechanics(self): return self.quantumMechanics
    def set_quantumMechanics(self, quantumMechanics): self.quantumMechanics = quantumMechanics
    def get_molecularMechanics(self): return self.molecularMechanics
    def set_molecularMechanics(self, molecularMechanics): self.molecularMechanics = molecularMechanics
    def get_multiscale(self): return self.multiscale
    def set_multiscale(self, multiscale): self.multiscale = multiscale
    def get_statisticalMechanics(self): return self.statisticalMechanics
    def set_statisticalMechanics(self, statisticalMechanics): self.statisticalMechanics = statisticalMechanics
    def hasContent_(self):
        if (
            self.quantumMechanics is not None or
            self.molecularMechanics is not None or
            self.multiscale is not None or
            self.statisticalMechanics is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='mcType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mcType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='mcType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='mcType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='mcType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.quantumMechanics is not None:
            self.quantumMechanics.export(outfile, level, namespace_, name_='quantumMechanics', pretty_print=pretty_print)
        if self.molecularMechanics is not None:
            self.molecularMechanics.export(outfile, level, namespace_, name_='molecularMechanics', pretty_print=pretty_print)
        if self.multiscale is not None:
            self.multiscale.export(outfile, level, namespace_, name_='multiscale', pretty_print=pretty_print)
        if self.statisticalMechanics is not None:
            self.statisticalMechanics.export(outfile, level, namespace_, name_='statisticalMechanics', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='mcType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.quantumMechanics is not None:
            showIndent(outfile, level)
            outfile.write('quantumMechanics=model_.qmCalcType(\n')
            self.quantumMechanics.exportLiteral(outfile, level, name_='quantumMechanics')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.molecularMechanics is not None:
            showIndent(outfile, level)
            outfile.write('molecularMechanics=model_.mmCalcType(\n')
            self.molecularMechanics.exportLiteral(outfile, level, name_='molecularMechanics')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.multiscale is not None:
            showIndent(outfile, level)
            outfile.write('multiscale=model_.msCalcType(\n')
            self.multiscale.exportLiteral(outfile, level, name_='multiscale')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.statisticalMechanics is not None:
            showIndent(outfile, level)
            outfile.write('statisticalMechanics=model_.smCalcType(\n')
            self.statisticalMechanics.exportLiteral(outfile, level, name_='statisticalMechanics')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quantumMechanics':
            obj_ = qmCalcType.factory()
            obj_.build(child_)
            self.quantumMechanics = obj_
            obj_.original_tagname_ = 'quantumMechanics'
        elif nodeName_ == 'molecularMechanics':
            obj_ = mmCalcType.factory()
            obj_.build(child_)
            self.molecularMechanics = obj_
            obj_.original_tagname_ = 'molecularMechanics'
        elif nodeName_ == 'multiscale':
            obj_ = msCalcType.factory()
            obj_.build(child_)
            self.multiscale = obj_
            obj_.original_tagname_ = 'multiscale'
        elif nodeName_ == 'statisticalMechanics':
            obj_ = smCalcType.factory()
            obj_.build(child_)
            self.statisticalMechanics = obj_
            obj_.original_tagname_ = 'statisticalMechanics'
# end class mcType


class qmCalcType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, singleReferenceState=None, multipleReferenceState=None):
        self.original_tagname_ = None
        self.singleReferenceState = singleReferenceState
        self.multipleReferenceState = multipleReferenceState
    def factory(*args_, **kwargs_):
        if qmCalcType.subclass:
            return qmCalcType.subclass(*args_, **kwargs_)
        else:
            return qmCalcType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_singleReferenceState(self): return self.singleReferenceState
    def set_singleReferenceState(self, singleReferenceState): self.singleReferenceState = singleReferenceState
    def get_multipleReferenceState(self): return self.multipleReferenceState
    def set_multipleReferenceState(self, multipleReferenceState): self.multipleReferenceState = multipleReferenceState
    def hasContent_(self):
        if (
            self.singleReferenceState is not None or
            self.multipleReferenceState is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='qmCalcType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='qmCalcType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='qmCalcType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='qmCalcType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='qmCalcType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.singleReferenceState is not None:
            self.singleReferenceState.export(outfile, level, namespace_, name_='singleReferenceState', pretty_print=pretty_print)
        if self.multipleReferenceState is not None:
            self.multipleReferenceState.export(outfile, level, namespace_, name_='multipleReferenceState', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='qmCalcType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.singleReferenceState is not None:
            showIndent(outfile, level)
            outfile.write('singleReferenceState=model_.srsMethodType(\n')
            self.singleReferenceState.exportLiteral(outfile, level, name_='singleReferenceState')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.multipleReferenceState is not None:
            showIndent(outfile, level)
            outfile.write('multipleReferenceState=model_.mrsMethodType(\n')
            self.multipleReferenceState.exportLiteral(outfile, level, name_='multipleReferenceState')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'singleReferenceState':
            obj_ = srsMethodType.factory()
            obj_.build(child_)
            self.singleReferenceState = obj_
            obj_.original_tagname_ = 'singleReferenceState'
        elif nodeName_ == 'multipleReferenceState':
            obj_ = mrsMethodType.factory()
            obj_.build(child_)
            self.multipleReferenceState = obj_
            obj_.original_tagname_ = 'multipleReferenceState'
# end class qmCalcType


class srsMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, singleDeterminant=None, multipleDeterminant=None):
        self.original_tagname_ = None
        self.singleDeterminant = singleDeterminant
        self.multipleDeterminant = multipleDeterminant
    def factory(*args_, **kwargs_):
        if srsMethodType.subclass:
            return srsMethodType.subclass(*args_, **kwargs_)
        else:
            return srsMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_singleDeterminant(self): return self.singleDeterminant
    def set_singleDeterminant(self, singleDeterminant): self.singleDeterminant = singleDeterminant
    def get_multipleDeterminant(self): return self.multipleDeterminant
    def set_multipleDeterminant(self, multipleDeterminant): self.multipleDeterminant = multipleDeterminant
    def hasContent_(self):
        if (
            self.singleDeterminant is not None or
            self.multipleDeterminant is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='srsMethodType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='srsMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='srsMethodType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='srsMethodType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='srsMethodType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.singleDeterminant is not None:
            self.singleDeterminant.export(outfile, level, namespace_, name_='singleDeterminant', pretty_print=pretty_print)
        if self.multipleDeterminant is not None:
            self.multipleDeterminant.export(outfile, level, namespace_, name_='multipleDeterminant', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='srsMethodType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.singleDeterminant is not None:
            showIndent(outfile, level)
            outfile.write('singleDeterminant=model_.srssdMethodType(\n')
            self.singleDeterminant.exportLiteral(outfile, level, name_='singleDeterminant')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.multipleDeterminant is not None:
            showIndent(outfile, level)
            outfile.write('multipleDeterminant=model_.srsmdMethodType(\n')
            self.multipleDeterminant.exportLiteral(outfile, level, name_='multipleDeterminant')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'singleDeterminant':
            obj_ = srssdMethodType.factory()
            obj_.build(child_)
            self.singleDeterminant = obj_
            obj_.original_tagname_ = 'singleDeterminant'
        elif nodeName_ == 'multipleDeterminant':
            obj_ = srsmdMethodType.factory()
            obj_.build(child_)
            self.multipleDeterminant = obj_
            obj_.original_tagname_ = 'multipleDeterminant'
# end class srsMethodType


class mrsMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, multipleDeterminant=None):
        self.original_tagname_ = None
        self.multipleDeterminant = multipleDeterminant
    def factory(*args_, **kwargs_):
        if mrsMethodType.subclass:
            return mrsMethodType.subclass(*args_, **kwargs_)
        else:
            return mrsMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_multipleDeterminant(self): return self.multipleDeterminant
    def set_multipleDeterminant(self, multipleDeterminant): self.multipleDeterminant = multipleDeterminant
    def hasContent_(self):
        if (
            self.multipleDeterminant is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='mrsMethodType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mrsMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='mrsMethodType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='mrsMethodType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='mrsMethodType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multipleDeterminant is not None:
            self.multipleDeterminant.export(outfile, level, namespace_, name_='multipleDeterminant', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='mrsMethodType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.multipleDeterminant is not None:
            showIndent(outfile, level)
            outfile.write('multipleDeterminant=model_.mrsmdMethodType(\n')
            self.multipleDeterminant.exportLiteral(outfile, level, name_='multipleDeterminant')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'multipleDeterminant':
            obj_ = mrsmdMethodType.factory()
            obj_.build(child_)
            self.multipleDeterminant = obj_
            obj_.original_tagname_ = 'multipleDeterminant'
# end class mrsMethodType


class mmCalcType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, parameterSet=None, forceField=None, energies=None):
        self.original_tagname_ = None
        self.parameterSet = _cast(None, parameterSet)
        self.forceField = _cast(None, forceField)
        self.energies = energies
    def factory(*args_, **kwargs_):
        if mmCalcType.subclass:
            return mmCalcType.subclass(*args_, **kwargs_)
        else:
            return mmCalcType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_energies(self): return self.energies
    def set_energies(self, energies): self.energies = energies
    def get_parameterSet(self): return self.parameterSet
    def set_parameterSet(self, parameterSet): self.parameterSet = parameterSet
    def get_forceField(self): return self.forceField
    def set_forceField(self, forceField): self.forceField = forceField
    def validate_forceFieldType(self, value):
        # Validate type forceFieldType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.energies is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='mmCalcType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mmCalcType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='mmCalcType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='mmCalcType'):
        if self.parameterSet is not None and 'parameterSet' not in already_processed:
            already_processed.add('parameterSet')
            outfile.write(' parameterSet=%s' % (self.gds_format_string(quote_attrib(self.parameterSet).encode(ExternalEncoding), input_name='parameterSet'), ))
        if self.forceField is not None and 'forceField' not in already_processed:
            already_processed.add('forceField')
            outfile.write(' forceField=%s' % (quote_attrib(self.forceField), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='mmCalcType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.energies is not None:
            self.energies.export(outfile, level, namespace_, name_='energies', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='mmCalcType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.parameterSet is not None and 'parameterSet' not in already_processed:
            already_processed.add('parameterSet')
            showIndent(outfile, level)
            outfile.write('parameterSet="%s",\n' % (self.parameterSet,))
        if self.forceField is not None and 'forceField' not in already_processed:
            already_processed.add('forceField')
            showIndent(outfile, level)
            outfile.write('forceField="%s",\n' % (self.forceField,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.energies is not None:
            showIndent(outfile, level)
            outfile.write('energies=model_.energyType(\n')
            self.energies.exportLiteral(outfile, level, name_='energies')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('parameterSet', node)
        if value is not None and 'parameterSet' not in already_processed:
            already_processed.add('parameterSet')
            self.parameterSet = value
        value = find_attr_value_('forceField', node)
        if value is not None and 'forceField' not in already_processed:
            already_processed.add('forceField')
            self.forceField = value
            self.validate_forceFieldType(self.forceField)    # validate type forceFieldType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'energies':
            obj_ = energyType.factory()
            obj_.build(child_)
            self.energies = obj_
            obj_.original_tagname_ = 'energies'
# end class mmCalcType


class msCalcType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, parameterSet=None, forceField=None, energies=None):
        self.original_tagname_ = None
        self.parameterSet = _cast(None, parameterSet)
        self.forceField = _cast(None, forceField)
        self.energies = energies
    def factory(*args_, **kwargs_):
        if msCalcType.subclass:
            return msCalcType.subclass(*args_, **kwargs_)
        else:
            return msCalcType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_energies(self): return self.energies
    def set_energies(self, energies): self.energies = energies
    def get_parameterSet(self): return self.parameterSet
    def set_parameterSet(self, parameterSet): self.parameterSet = parameterSet
    def get_forceField(self): return self.forceField
    def set_forceField(self, forceField): self.forceField = forceField
    def validate_forceFieldType(self, value):
        # Validate type forceFieldType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.energies is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='msCalcType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='msCalcType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='msCalcType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='msCalcType'):
        if self.parameterSet is not None and 'parameterSet' not in already_processed:
            already_processed.add('parameterSet')
            outfile.write(' parameterSet=%s' % (self.gds_format_string(quote_attrib(self.parameterSet).encode(ExternalEncoding), input_name='parameterSet'), ))
        if self.forceField is not None and 'forceField' not in already_processed:
            already_processed.add('forceField')
            outfile.write(' forceField=%s' % (quote_attrib(self.forceField), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='msCalcType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.energies is not None:
            self.energies.export(outfile, level, namespace_, name_='energies', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='msCalcType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.parameterSet is not None and 'parameterSet' not in already_processed:
            already_processed.add('parameterSet')
            showIndent(outfile, level)
            outfile.write('parameterSet="%s",\n' % (self.parameterSet,))
        if self.forceField is not None and 'forceField' not in already_processed:
            already_processed.add('forceField')
            showIndent(outfile, level)
            outfile.write('forceField="%s",\n' % (self.forceField,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.energies is not None:
            showIndent(outfile, level)
            outfile.write('energies=model_.energyType(\n')
            self.energies.exportLiteral(outfile, level, name_='energies')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('parameterSet', node)
        if value is not None and 'parameterSet' not in already_processed:
            already_processed.add('parameterSet')
            self.parameterSet = value
        value = find_attr_value_('forceField', node)
        if value is not None and 'forceField' not in already_processed:
            already_processed.add('forceField')
            self.forceField = value
            self.validate_forceFieldType(self.forceField)    # validate type forceFieldType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'energies':
            obj_ = energyType.factory()
            obj_.build(child_)
            self.energies = obj_
            obj_.original_tagname_ = 'energies'
# end class msCalcType


class smCalcType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, parameterSet=None, forceField=None, condition=None, properties=None):
        self.original_tagname_ = None
        self.parameterSet = _cast(None, parameterSet)
        self.forceField = _cast(None, forceField)
        if condition is None:
            self.condition = []
        else:
            self.condition = condition
        self.properties = properties
    def factory(*args_, **kwargs_):
        if smCalcType.subclass:
            return smCalcType.subclass(*args_, **kwargs_)
        else:
            return smCalcType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_condition(self): return self.condition
    def set_condition(self, condition): self.condition = condition
    def add_condition(self, value): self.condition.append(value)
    def insert_condition_at(self, index, value): self.condition.insert(index, value)
    def replace_condition_at(self, index, value): self.condition[index] = value
    def get_properties(self): return self.properties
    def set_properties(self, properties): self.properties = properties
    def get_parameterSet(self): return self.parameterSet
    def set_parameterSet(self, parameterSet): self.parameterSet = parameterSet
    def get_forceField(self): return self.forceField
    def set_forceField(self, forceField): self.forceField = forceField
    def validate_forceFieldType(self, value):
        # Validate type forceFieldType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.condition or
            self.properties is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='smCalcType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='smCalcType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='smCalcType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='smCalcType'):
        if self.parameterSet is not None and 'parameterSet' not in already_processed:
            already_processed.add('parameterSet')
            outfile.write(' parameterSet=%s' % (self.gds_format_string(quote_attrib(self.parameterSet).encode(ExternalEncoding), input_name='parameterSet'), ))
        if self.forceField is not None and 'forceField' not in already_processed:
            already_processed.add('forceField')
            outfile.write(' forceField=%s' % (quote_attrib(self.forceField), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='smCalcType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for condition_ in self.condition:
            condition_.export(outfile, level, namespace_, name_='condition', pretty_print=pretty_print)
        if self.properties is not None:
            self.properties.export(outfile, level, namespace_, name_='properties', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='smCalcType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.parameterSet is not None and 'parameterSet' not in already_processed:
            already_processed.add('parameterSet')
            showIndent(outfile, level)
            outfile.write('parameterSet="%s",\n' % (self.parameterSet,))
        if self.forceField is not None and 'forceField' not in already_processed:
            already_processed.add('forceField')
            showIndent(outfile, level)
            outfile.write('forceField="%s",\n' % (self.forceField,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('condition=[\n')
        level += 1
        for condition_ in self.condition:
            showIndent(outfile, level)
            outfile.write('model_.conditionType(\n')
            condition_.exportLiteral(outfile, level, name_='conditionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.properties is not None:
            showIndent(outfile, level)
            outfile.write('properties=model_.propertiesType(\n')
            self.properties.exportLiteral(outfile, level, name_='properties')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('parameterSet', node)
        if value is not None and 'parameterSet' not in already_processed:
            already_processed.add('parameterSet')
            self.parameterSet = value
        value = find_attr_value_('forceField', node)
        if value is not None and 'forceField' not in already_processed:
            already_processed.add('forceField')
            self.forceField = value
            self.validate_forceFieldType(self.forceField)    # validate type forceFieldType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'condition':
            obj_ = conditionType.factory()
            obj_.build(child_)
            self.condition.append(obj_)
            obj_.original_tagname_ = 'condition'
        elif nodeName_ == 'properties':
            obj_ = propertiesType.factory()
            obj_.build(child_)
            self.properties = obj_
            obj_.original_tagname_ = 'properties'
# end class smCalcType


class srssdMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, abinitioScf=None, semiEmpiricalScf=None, dft=None, mp2=None, mp3=None, mp4=None):
        self.original_tagname_ = None
        self.abinitioScf = abinitioScf
        self.semiEmpiricalScf = semiEmpiricalScf
        self.dft = dft
        self.mp2 = mp2
        self.mp3 = mp3
        self.mp4 = mp4
    def factory(*args_, **kwargs_):
        if srssdMethodType.subclass:
            return srssdMethodType.subclass(*args_, **kwargs_)
        else:
            return srssdMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_abinitioScf(self): return self.abinitioScf
    def set_abinitioScf(self, abinitioScf): self.abinitioScf = abinitioScf
    def get_semiEmpiricalScf(self): return self.semiEmpiricalScf
    def set_semiEmpiricalScf(self, semiEmpiricalScf): self.semiEmpiricalScf = semiEmpiricalScf
    def get_dft(self): return self.dft
    def set_dft(self, dft): self.dft = dft
    def get_mp2(self): return self.mp2
    def set_mp2(self, mp2): self.mp2 = mp2
    def get_mp3(self): return self.mp3
    def set_mp3(self, mp3): self.mp3 = mp3
    def get_mp4(self): return self.mp4
    def set_mp4(self, mp4): self.mp4 = mp4
    def hasContent_(self):
        if (
            self.abinitioScf is not None or
            self.semiEmpiricalScf is not None or
            self.dft is not None or
            self.mp2 is not None or
            self.mp3 is not None or
            self.mp4 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='srssdMethodType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='srssdMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='srssdMethodType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='srssdMethodType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='srssdMethodType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.abinitioScf is not None:
            self.abinitioScf.export(outfile, level, namespace_, name_='abinitioScf', pretty_print=pretty_print)
        if self.semiEmpiricalScf is not None:
            self.semiEmpiricalScf.export(outfile, level, namespace_, name_='semiEmpiricalScf', pretty_print=pretty_print)
        if self.dft is not None:
            self.dft.export(outfile, level, namespace_, name_='dft', pretty_print=pretty_print)
        if self.mp2 is not None:
            self.mp2.export(outfile, level, namespace_, name_='mp2', pretty_print=pretty_print)
        if self.mp3 is not None:
            self.mp3.export(outfile, level, namespace_, name_='mp3', pretty_print=pretty_print)
        if self.mp4 is not None:
            self.mp4.export(outfile, level, namespace_, name_='mp4', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='srssdMethodType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.abinitioScf is not None:
            showIndent(outfile, level)
            outfile.write('abinitioScf=model_.resultType(\n')
            self.abinitioScf.exportLiteral(outfile, level, name_='abinitioScf')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.semiEmpiricalScf is not None:
            showIndent(outfile, level)
            outfile.write('semiEmpiricalScf=model_.resultType(\n')
            self.semiEmpiricalScf.exportLiteral(outfile, level, name_='semiEmpiricalScf')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dft is not None:
            showIndent(outfile, level)
            outfile.write('dft=model_.resultType(\n')
            self.dft.exportLiteral(outfile, level, name_='dft')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.mp2 is not None:
            showIndent(outfile, level)
            outfile.write('mp2=model_.resultType(\n')
            self.mp2.exportLiteral(outfile, level, name_='mp2')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.mp3 is not None:
            showIndent(outfile, level)
            outfile.write('mp3=model_.resultType(\n')
            self.mp3.exportLiteral(outfile, level, name_='mp3')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.mp4 is not None:
            showIndent(outfile, level)
            outfile.write('mp4=model_.resultType(\n')
            self.mp4.exportLiteral(outfile, level, name_='mp4')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'abinitioScf':
            obj_ = resultType.factory()
            obj_.build(child_)
            self.abinitioScf = obj_
            obj_.original_tagname_ = 'abinitioScf'
        elif nodeName_ == 'semiEmpiricalScf':
            obj_ = resultType.factory()
            obj_.build(child_)
            self.semiEmpiricalScf = obj_
            obj_.original_tagname_ = 'semiEmpiricalScf'
        elif nodeName_ == 'dft':
            obj_ = resultType.factory()
            obj_.build(child_)
            self.dft = obj_
            obj_.original_tagname_ = 'dft'
        elif nodeName_ == 'mp2':
            obj_ = resultType.factory()
            obj_.build(child_)
            self.mp2 = obj_
            obj_.original_tagname_ = 'mp2'
        elif nodeName_ == 'mp3':
            obj_ = resultType.factory()
            obj_.build(child_)
            self.mp3 = obj_
            obj_.original_tagname_ = 'mp3'
        elif nodeName_ == 'mp4':
            obj_ = resultType.factory()
            obj_.build(child_)
            self.mp4 = obj_
            obj_.original_tagname_ = 'mp4'
# end class srssdMethodType


class srsmdMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cis=None, cisd=None, ccd=None, ccsd=None, ccsd_t=None, scf=None):
        self.original_tagname_ = None
        self.cis = cis
        self.cisd = cisd
        self.ccd = ccd
        self.ccsd = ccsd
        self.ccsd_t = ccsd_t
        self.scf = scf
    def factory(*args_, **kwargs_):
        if srsmdMethodType.subclass:
            return srsmdMethodType.subclass(*args_, **kwargs_)
        else:
            return srsmdMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cis(self): return self.cis
    def set_cis(self, cis): self.cis = cis
    def get_cisd(self): return self.cisd
    def set_cisd(self, cisd): self.cisd = cisd
    def get_ccd(self): return self.ccd
    def set_ccd(self, ccd): self.ccd = ccd
    def get_ccsd(self): return self.ccsd
    def set_ccsd(self, ccsd): self.ccsd = ccsd
    def get_ccsd_t(self): return self.ccsd_t
    def set_ccsd_t(self, ccsd_t): self.ccsd_t = ccsd_t
    def get_scf(self): return self.scf
    def set_scf(self, scf): self.scf = scf
    def hasContent_(self):
        if (
            self.cis is not None or
            self.cisd is not None or
            self.ccd is not None or
            self.ccsd is not None or
            self.ccsd_t is not None or
            self.scf is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='srsmdMethodType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='srsmdMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='srsmdMethodType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='srsmdMethodType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='srsmdMethodType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cis is not None:
            self.cis.export(outfile, level, namespace_, name_='cis', pretty_print=pretty_print)
        if self.cisd is not None:
            self.cisd.export(outfile, level, namespace_, name_='cisd', pretty_print=pretty_print)
        if self.ccd is not None:
            self.ccd.export(outfile, level, namespace_, name_='ccd', pretty_print=pretty_print)
        if self.ccsd is not None:
            self.ccsd.export(outfile, level, namespace_, name_='ccsd', pretty_print=pretty_print)
        if self.ccsd_t is not None:
            self.ccsd_t.export(outfile, level, namespace_, name_='ccsd-t', pretty_print=pretty_print)
        if self.scf is not None:
            self.scf.export(outfile, level, namespace_, name_='scf', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='srsmdMethodType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.cis is not None:
            showIndent(outfile, level)
            outfile.write('cis=model_.resultType(\n')
            self.cis.exportLiteral(outfile, level, name_='cis')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cisd is not None:
            showIndent(outfile, level)
            outfile.write('cisd=model_.resultType(\n')
            self.cisd.exportLiteral(outfile, level, name_='cisd')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ccd is not None:
            showIndent(outfile, level)
            outfile.write('ccd=model_.resultType(\n')
            self.ccd.exportLiteral(outfile, level, name_='ccd')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ccsd is not None:
            showIndent(outfile, level)
            outfile.write('ccsd=model_.resultType(\n')
            self.ccsd.exportLiteral(outfile, level, name_='ccsd')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ccsd_t is not None:
            showIndent(outfile, level)
            outfile.write('ccsd_t=model_.resultType(\n')
            self.ccsd_t.exportLiteral(outfile, level, name_='ccsd_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.scf is not None:
            showIndent(outfile, level)
            outfile.write('scf=model_.resultType(\n')
            self.scf.exportLiteral(outfile, level, name_='scf')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cis':
            obj_ = resultType.factory()
            obj_.build(child_)
            self.cis = obj_
            obj_.original_tagname_ = 'cis'
        elif nodeName_ == 'cisd':
            obj_ = resultType.factory()
            obj_.build(child_)
            self.cisd = obj_
            obj_.original_tagname_ = 'cisd'
        elif nodeName_ == 'ccd':
            obj_ = resultType.factory()
            obj_.build(child_)
            self.ccd = obj_
            obj_.original_tagname_ = 'ccd'
        elif nodeName_ == 'ccsd':
            obj_ = resultType.factory()
            obj_.build(child_)
            self.ccsd = obj_
            obj_.original_tagname_ = 'ccsd'
        elif nodeName_ == 'ccsd-t':
            obj_ = resultType.factory()
            obj_.build(child_)
            self.ccsd_t = obj_
            obj_.original_tagname_ = 'ccsd-t'
        elif nodeName_ == 'scf':
            obj_ = resultType.factory()
            obj_.build(child_)
            self.scf = obj_
            obj_.original_tagname_ = 'scf'
# end class srsmdMethodType


class mrsmdMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mcscf=None, caspt2=None):
        self.original_tagname_ = None
        self.mcscf = mcscf
        self.caspt2 = caspt2
    def factory(*args_, **kwargs_):
        if mrsmdMethodType.subclass:
            return mrsmdMethodType.subclass(*args_, **kwargs_)
        else:
            return mrsmdMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mcscf(self): return self.mcscf
    def set_mcscf(self, mcscf): self.mcscf = mcscf
    def get_caspt2(self): return self.caspt2
    def set_caspt2(self, caspt2): self.caspt2 = caspt2
    def hasContent_(self):
        if (
            self.mcscf is not None or
            self.caspt2 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='mrsmdMethodType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mrsmdMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='mrsmdMethodType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='mrsmdMethodType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='mrsmdMethodType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mcscf is not None:
            self.mcscf.export(outfile, level, namespace_, name_='mcscf', pretty_print=pretty_print)
        if self.caspt2 is not None:
            self.caspt2.export(outfile, level, namespace_, name_='caspt2', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='mrsmdMethodType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.mcscf is not None:
            showIndent(outfile, level)
            outfile.write('mcscf=model_.resultType(\n')
            self.mcscf.exportLiteral(outfile, level, name_='mcscf')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.caspt2 is not None:
            showIndent(outfile, level)
            outfile.write('caspt2=model_.resultType(\n')
            self.caspt2.exportLiteral(outfile, level, name_='caspt2')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mcscf':
            obj_ = resultType.factory()
            obj_.build(child_)
            self.mcscf = obj_
            obj_.original_tagname_ = 'mcscf'
        elif nodeName_ == 'caspt2':
            obj_ = resultType.factory()
            obj_.build(child_)
            self.caspt2 = obj_
            obj_.original_tagname_ = 'caspt2'
# end class mrsmdMethodType


class resultType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, numberBasisFunc=None, spinType=None, dispersionCorrection=None, basisSet=None, dftFlavor=None, dftFunctional=None, methodology=None, exchangeFunctional=None, correlationFunctional=None, energies=None, properties=None, waveFunction=None, vibrationalAnalysis=None, electronicSpectra=None):
        self.original_tagname_ = None
        self.numberBasisFunc = _cast(int, numberBasisFunc)
        self.spinType = _cast(None, spinType)
        self.dispersionCorrection = _cast(None, dispersionCorrection)
        self.basisSet = _cast(None, basisSet)
        self.dftFlavor = _cast(None, dftFlavor)
        self.dftFunctional = _cast(None, dftFunctional)
        self.methodology = _cast(None, methodology)
        self.exchangeFunctional = _cast(None, exchangeFunctional)
        self.correlationFunctional = _cast(None, correlationFunctional)
        self.energies = energies
        self.properties = properties
        self.waveFunction = waveFunction
        self.vibrationalAnalysis = vibrationalAnalysis
        self.electronicSpectra = electronicSpectra
    def factory(*args_, **kwargs_):
        if resultType.subclass:
            return resultType.subclass(*args_, **kwargs_)
        else:
            return resultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_energies(self): return self.energies
    def set_energies(self, energies): self.energies = energies
    def get_properties(self): return self.properties
    def set_properties(self, properties): self.properties = properties
    def get_waveFunction(self): return self.waveFunction
    def set_waveFunction(self, waveFunction): self.waveFunction = waveFunction
    def get_vibrationalAnalysis(self): return self.vibrationalAnalysis
    def set_vibrationalAnalysis(self, vibrationalAnalysis): self.vibrationalAnalysis = vibrationalAnalysis
    def get_electronicSpectra(self): return self.electronicSpectra
    def set_electronicSpectra(self, electronicSpectra): self.electronicSpectra = electronicSpectra
    def get_numberBasisFunc(self): return self.numberBasisFunc
    def set_numberBasisFunc(self, numberBasisFunc): self.numberBasisFunc = numberBasisFunc
    def get_spinType(self): return self.spinType
    def set_spinType(self, spinType): self.spinType = spinType
    def get_dispersionCorrection(self): return self.dispersionCorrection
    def set_dispersionCorrection(self, dispersionCorrection): self.dispersionCorrection = dispersionCorrection
    def get_basisSet(self): return self.basisSet
    def set_basisSet(self, basisSet): self.basisSet = basisSet
    def get_dftFlavor(self): return self.dftFlavor
    def set_dftFlavor(self, dftFlavor): self.dftFlavor = dftFlavor
    def get_dftFunctional(self): return self.dftFunctional
    def set_dftFunctional(self, dftFunctional): self.dftFunctional = dftFunctional
    def get_methodology(self): return self.methodology
    def set_methodology(self, methodology): self.methodology = methodology
    def get_exchangeFunctional(self): return self.exchangeFunctional
    def set_exchangeFunctional(self, exchangeFunctional): self.exchangeFunctional = exchangeFunctional
    def get_correlationFunctional(self): return self.correlationFunctional
    def set_correlationFunctional(self, correlationFunctional): self.correlationFunctional = correlationFunctional
    def validate_spinTypeType(self, value):
        # Validate type spinTypeType, a restriction on xs:string.
        pass
    def validate_dftFlavorType(self, value):
        # Validate type dftFlavorType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.energies is not None or
            self.properties is not None or
            self.waveFunction is not None or
            self.vibrationalAnalysis is not None or
            self.electronicSpectra is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='resultType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='resultType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='resultType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='resultType'):
        if self.numberBasisFunc is not None and 'numberBasisFunc' not in already_processed:
            already_processed.add('numberBasisFunc')
            outfile.write(' numberBasisFunc="%s"' % self.gds_format_integer(self.numberBasisFunc, input_name='numberBasisFunc'))
        if self.spinType is not None and 'spinType' not in already_processed:
            already_processed.add('spinType')
            outfile.write(' spinType=%s' % (quote_attrib(self.spinType), ))
        if self.dispersionCorrection is not None and 'dispersionCorrection' not in already_processed:
            already_processed.add('dispersionCorrection')
            outfile.write(' dispersionCorrection=%s' % (self.gds_format_string(quote_attrib(self.dispersionCorrection).encode(ExternalEncoding), input_name='dispersionCorrection'), ))
        if self.basisSet is not None and 'basisSet' not in already_processed:
            already_processed.add('basisSet')
            outfile.write(' basisSet=%s' % (self.gds_format_string(quote_attrib(self.basisSet).encode(ExternalEncoding), input_name='basisSet'), ))
        if self.dftFlavor is not None and 'dftFlavor' not in already_processed:
            already_processed.add('dftFlavor')
            outfile.write(' dftFlavor=%s' % (quote_attrib(self.dftFlavor), ))
        if self.dftFunctional is not None and 'dftFunctional' not in already_processed:
            already_processed.add('dftFunctional')
            outfile.write(' dftFunctional=%s' % (self.gds_format_string(quote_attrib(self.dftFunctional).encode(ExternalEncoding), input_name='dftFunctional'), ))
        if self.methodology is not None and 'methodology' not in already_processed:
            already_processed.add('methodology')
            outfile.write(' methodology=%s' % (self.gds_format_string(quote_attrib(self.methodology).encode(ExternalEncoding), input_name='methodology'), ))
        if self.exchangeFunctional is not None and 'exchangeFunctional' not in already_processed:
            already_processed.add('exchangeFunctional')
            outfile.write(' exchangeFunctional=%s' % (self.gds_format_string(quote_attrib(self.exchangeFunctional).encode(ExternalEncoding), input_name='exchangeFunctional'), ))
        if self.correlationFunctional is not None and 'correlationFunctional' not in already_processed:
            already_processed.add('correlationFunctional')
            outfile.write(' correlationFunctional=%s' % (self.gds_format_string(quote_attrib(self.correlationFunctional).encode(ExternalEncoding), input_name='correlationFunctional'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='resultType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.energies is not None:
            self.energies.export(outfile, level, namespace_, name_='energies', pretty_print=pretty_print)
        if self.properties is not None:
            self.properties.export(outfile, level, namespace_, name_='properties', pretty_print=pretty_print)
        if self.waveFunction is not None:
            self.waveFunction.export(outfile, level, namespace_, name_='waveFunction', pretty_print=pretty_print)
        if self.vibrationalAnalysis is not None:
            self.vibrationalAnalysis.export(outfile, level, namespace_, name_='vibrationalAnalysis', pretty_print=pretty_print)
        if self.electronicSpectra is not None:
            self.electronicSpectra.export(outfile, level, namespace_, name_='electronicSpectra', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='resultType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numberBasisFunc is not None and 'numberBasisFunc' not in already_processed:
            already_processed.add('numberBasisFunc')
            showIndent(outfile, level)
            outfile.write('numberBasisFunc=%d,\n' % (self.numberBasisFunc,))
        if self.spinType is not None and 'spinType' not in already_processed:
            already_processed.add('spinType')
            showIndent(outfile, level)
            outfile.write('spinType="%s",\n' % (self.spinType,))
        if self.dispersionCorrection is not None and 'dispersionCorrection' not in already_processed:
            already_processed.add('dispersionCorrection')
            showIndent(outfile, level)
            outfile.write('dispersionCorrection="%s",\n' % (self.dispersionCorrection,))
        if self.basisSet is not None and 'basisSet' not in already_processed:
            already_processed.add('basisSet')
            showIndent(outfile, level)
            outfile.write('basisSet="%s",\n' % (self.basisSet,))
        if self.dftFlavor is not None and 'dftFlavor' not in already_processed:
            already_processed.add('dftFlavor')
            showIndent(outfile, level)
            outfile.write('dftFlavor="%s",\n' % (self.dftFlavor,))
        if self.dftFunctional is not None and 'dftFunctional' not in already_processed:
            already_processed.add('dftFunctional')
            showIndent(outfile, level)
            outfile.write('dftFunctional="%s",\n' % (self.dftFunctional,))
        if self.methodology is not None and 'methodology' not in already_processed:
            already_processed.add('methodology')
            showIndent(outfile, level)
            outfile.write('methodology="%s",\n' % (self.methodology,))
        if self.exchangeFunctional is not None and 'exchangeFunctional' not in already_processed:
            already_processed.add('exchangeFunctional')
            showIndent(outfile, level)
            outfile.write('exchangeFunctional="%s",\n' % (self.exchangeFunctional,))
        if self.correlationFunctional is not None and 'correlationFunctional' not in already_processed:
            already_processed.add('correlationFunctional')
            showIndent(outfile, level)
            outfile.write('correlationFunctional="%s",\n' % (self.correlationFunctional,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.energies is not None:
            showIndent(outfile, level)
            outfile.write('energies=model_.energiesType(\n')
            self.energies.exportLiteral(outfile, level, name_='energies')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.properties is not None:
            showIndent(outfile, level)
            outfile.write('properties=model_.propertiesType(\n')
            self.properties.exportLiteral(outfile, level, name_='properties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.waveFunction is not None:
            showIndent(outfile, level)
            outfile.write('waveFunction=model_.waveFunctionType(\n')
            self.waveFunction.exportLiteral(outfile, level, name_='waveFunction')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.vibrationalAnalysis is not None:
            showIndent(outfile, level)
            outfile.write('vibrationalAnalysis=model_.vibAnalysisType(\n')
            self.vibrationalAnalysis.exportLiteral(outfile, level, name_='vibrationalAnalysis')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.electronicSpectra is not None:
            showIndent(outfile, level)
            outfile.write('electronicSpectra=model_.elecSpectraType(\n')
            self.electronicSpectra.exportLiteral(outfile, level, name_='electronicSpectra')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberBasisFunc', node)
        if value is not None and 'numberBasisFunc' not in already_processed:
            already_processed.add('numberBasisFunc')
            try:
                self.numberBasisFunc = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.numberBasisFunc < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('spinType', node)
        if value is not None and 'spinType' not in already_processed:
            already_processed.add('spinType')
            self.spinType = value
            self.validate_spinTypeType(self.spinType)    # validate type spinTypeType
        value = find_attr_value_('dispersionCorrection', node)
        if value is not None and 'dispersionCorrection' not in already_processed:
            already_processed.add('dispersionCorrection')
            self.dispersionCorrection = value
        value = find_attr_value_('basisSet', node)
        if value is not None and 'basisSet' not in already_processed:
            already_processed.add('basisSet')
            self.basisSet = value
        value = find_attr_value_('dftFlavor', node)
        if value is not None and 'dftFlavor' not in already_processed:
            already_processed.add('dftFlavor')
            self.dftFlavor = value
            self.validate_dftFlavorType(self.dftFlavor)    # validate type dftFlavorType
        value = find_attr_value_('dftFunctional', node)
        if value is not None and 'dftFunctional' not in already_processed:
            already_processed.add('dftFunctional')
            self.dftFunctional = value
        value = find_attr_value_('methodology', node)
        if value is not None and 'methodology' not in already_processed:
            already_processed.add('methodology')
            self.methodology = value
        value = find_attr_value_('exchangeFunctional', node)
        if value is not None and 'exchangeFunctional' not in already_processed:
            already_processed.add('exchangeFunctional')
            self.exchangeFunctional = value
        value = find_attr_value_('correlationFunctional', node)
        if value is not None and 'correlationFunctional' not in already_processed:
            already_processed.add('correlationFunctional')
            self.correlationFunctional = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'energies':
            obj_ = energiesType.factory()
            obj_.build(child_)
            self.energies = obj_
            obj_.original_tagname_ = 'energies'
        elif nodeName_ == 'properties':
            obj_ = propertiesType.factory()
            obj_.build(child_)
            self.properties = obj_
            obj_.original_tagname_ = 'properties'
        elif nodeName_ == 'waveFunction':
            obj_ = waveFunctionType.factory()
            obj_.build(child_)
            self.waveFunction = obj_
            obj_.original_tagname_ = 'waveFunction'
        elif nodeName_ == 'vibrationalAnalysis':
            obj_ = vibAnalysisType.factory()
            obj_.build(child_)
            self.vibrationalAnalysis = obj_
            obj_.original_tagname_ = 'vibrationalAnalysis'
        elif nodeName_ == 'electronicSpectra':
            obj_ = elecSpectraType.factory()
            obj_.build(child_)
            self.electronicSpectra = obj_
            obj_.original_tagname_ = 'electronicSpectra'
# end class resultType


class energiesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unit=None, energy=None):
        self.original_tagname_ = None
        self.unit = _cast(None, unit)
        if energy is None:
            self.energy = []
        else:
            self.energy = energy
    def factory(*args_, **kwargs_):
        if energiesType.subclass:
            return energiesType.subclass(*args_, **kwargs_)
        else:
            return energiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_energy(self): return self.energy
    def set_energy(self, energy): self.energy = energy
    def add_energy(self, value): self.energy.append(value)
    def insert_energy_at(self, index, value): self.energy.insert(index, value)
    def replace_energy_at(self, index, value): self.energy[index] = value
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def hasContent_(self):
        if (
            self.energy
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='energiesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='energiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='energiesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='energiesType'):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_format_string(quote_attrib(self.unit).encode(ExternalEncoding), input_name='unit'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='energiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for energy_ in self.energy:
            energy_.export(outfile, level, namespace_, name_='energy', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='energiesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('energy=[\n')
        level += 1
        for energy_ in self.energy:
            showIndent(outfile, level)
            outfile.write('model_.energyType(\n')
            energy_.exportLiteral(outfile, level, name_='energyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'energy':
            obj_ = energyType.factory()
            obj_.build(child_)
            self.energy.append(obj_)
            obj_.original_tagname_ = 'energy'
# end class energiesType


class energyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, unit=None, valueOf_=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.unit = _cast(None, unit)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if energyType.subclass:
            return energyType.subclass(*args_, **kwargs_)
        else:
            return energyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='energyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='energyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='energyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='energyType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_format_string(quote_attrib(self.unit).encode(ExternalEncoding), input_name='unit'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='energyType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='energyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class energyType


class propertiesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, systemProperty=None, moleculeProperty=None, residueProperty=None, groupProperty=None, atomProperty=None):
        self.original_tagname_ = None
        if systemProperty is None:
            self.systemProperty = []
        else:
            self.systemProperty = systemProperty
        if moleculeProperty is None:
            self.moleculeProperty = []
        else:
            self.moleculeProperty = moleculeProperty
        if residueProperty is None:
            self.residueProperty = []
        else:
            self.residueProperty = residueProperty
        if groupProperty is None:
            self.groupProperty = []
        else:
            self.groupProperty = groupProperty
        if atomProperty is None:
            self.atomProperty = []
        else:
            self.atomProperty = atomProperty
    def factory(*args_, **kwargs_):
        if propertiesType.subclass:
            return propertiesType.subclass(*args_, **kwargs_)
        else:
            return propertiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_systemProperty(self): return self.systemProperty
    def set_systemProperty(self, systemProperty): self.systemProperty = systemProperty
    def add_systemProperty(self, value): self.systemProperty.append(value)
    def insert_systemProperty_at(self, index, value): self.systemProperty.insert(index, value)
    def replace_systemProperty_at(self, index, value): self.systemProperty[index] = value
    def get_moleculeProperty(self): return self.moleculeProperty
    def set_moleculeProperty(self, moleculeProperty): self.moleculeProperty = moleculeProperty
    def add_moleculeProperty(self, value): self.moleculeProperty.append(value)
    def insert_moleculeProperty_at(self, index, value): self.moleculeProperty.insert(index, value)
    def replace_moleculeProperty_at(self, index, value): self.moleculeProperty[index] = value
    def get_residueProperty(self): return self.residueProperty
    def set_residueProperty(self, residueProperty): self.residueProperty = residueProperty
    def add_residueProperty(self, value): self.residueProperty.append(value)
    def insert_residueProperty_at(self, index, value): self.residueProperty.insert(index, value)
    def replace_residueProperty_at(self, index, value): self.residueProperty[index] = value
    def get_groupProperty(self): return self.groupProperty
    def set_groupProperty(self, groupProperty): self.groupProperty = groupProperty
    def add_groupProperty(self, value): self.groupProperty.append(value)
    def insert_groupProperty_at(self, index, value): self.groupProperty.insert(index, value)
    def replace_groupProperty_at(self, index, value): self.groupProperty[index] = value
    def get_atomProperty(self): return self.atomProperty
    def set_atomProperty(self, atomProperty): self.atomProperty = atomProperty
    def add_atomProperty(self, value): self.atomProperty.append(value)
    def insert_atomProperty_at(self, index, value): self.atomProperty.insert(index, value)
    def replace_atomProperty_at(self, index, value): self.atomProperty[index] = value
    def hasContent_(self):
        if (
            self.systemProperty or
            self.moleculeProperty or
            self.residueProperty or
            self.groupProperty or
            self.atomProperty
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='propertiesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='propertiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='propertiesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='propertiesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='propertiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for systemProperty_ in self.systemProperty:
            systemProperty_.export(outfile, level, namespace_, name_='systemProperty', pretty_print=pretty_print)
        for moleculeProperty_ in self.moleculeProperty:
            moleculeProperty_.export(outfile, level, namespace_, name_='moleculeProperty', pretty_print=pretty_print)
        for residueProperty_ in self.residueProperty:
            residueProperty_.export(outfile, level, namespace_, name_='residueProperty', pretty_print=pretty_print)
        for groupProperty_ in self.groupProperty:
            groupProperty_.export(outfile, level, namespace_, name_='groupProperty', pretty_print=pretty_print)
        for atomProperty_ in self.atomProperty:
            atomProperty_.export(outfile, level, namespace_, name_='atomProperty', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='propertiesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('systemProperty=[\n')
        level += 1
        for systemProperty_ in self.systemProperty:
            showIndent(outfile, level)
            outfile.write('model_.propertyType(\n')
            systemProperty_.exportLiteral(outfile, level, name_='propertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('moleculeProperty=[\n')
        level += 1
        for moleculeProperty_ in self.moleculeProperty:
            showIndent(outfile, level)
            outfile.write('model_.propertyType(\n')
            moleculeProperty_.exportLiteral(outfile, level, name_='propertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('residueProperty=[\n')
        level += 1
        for residueProperty_ in self.residueProperty:
            showIndent(outfile, level)
            outfile.write('model_.propertyType(\n')
            residueProperty_.exportLiteral(outfile, level, name_='propertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('groupProperty=[\n')
        level += 1
        for groupProperty_ in self.groupProperty:
            showIndent(outfile, level)
            outfile.write('model_.propertyType(\n')
            groupProperty_.exportLiteral(outfile, level, name_='propertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('atomProperty=[\n')
        level += 1
        for atomProperty_ in self.atomProperty:
            showIndent(outfile, level)
            outfile.write('model_.propertyType(\n')
            atomProperty_.exportLiteral(outfile, level, name_='propertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'systemProperty':
            obj_ = propertyType.factory()
            obj_.build(child_)
            self.systemProperty.append(obj_)
            obj_.original_tagname_ = 'systemProperty'
        elif nodeName_ == 'moleculeProperty':
            obj_ = propertyType.factory()
            obj_.build(child_)
            self.moleculeProperty.append(obj_)
            obj_.original_tagname_ = 'moleculeProperty'
        elif nodeName_ == 'residueProperty':
            obj_ = propertyType.factory()
            obj_.build(child_)
            self.residueProperty.append(obj_)
            obj_.original_tagname_ = 'residueProperty'
        elif nodeName_ == 'groupProperty':
            obj_ = propertyType.factory()
            obj_.build(child_)
            self.groupProperty.append(obj_)
            obj_.original_tagname_ = 'groupProperty'
        elif nodeName_ == 'atomProperty':
            obj_ = propertyType.factory()
            obj_.build(child_)
            self.atomProperty.append(obj_)
            obj_.original_tagname_ = 'atomProperty'
# end class propertiesType


class dataWithUnitsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unit=None, valueOf_=None):
        self.original_tagname_ = None
        self.unit = _cast(None, unit)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if dataWithUnitsType.subclass:
            return dataWithUnitsType.subclass(*args_, **kwargs_)
        else:
            return dataWithUnitsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        return True
    def export(self, outfile, level, namespace_='cs:', name_='dataWithUnitsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dataWithUnitsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='dataWithUnitsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='dataWithUnitsType'):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_format_string(quote_attrib(self.unit).encode(ExternalEncoding), input_name='unit'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='dataWithUnitsType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='dataWithUnitsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dataWithUnitsType


class propertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, moleculeId=None, name=None, datatype=None, propertyCount=None, atomId=None, residueId=None, groupId=None, unit=None, valueOf_=None):
        self.original_tagname_ = None
        self.moleculeId = _cast(None, moleculeId)
        self.name = _cast(None, name)
        self.datatype = _cast(None, datatype)
        self.propertyCount = _cast(int, propertyCount)
        self.atomId = _cast(None, atomId)
        self.residueId = _cast(None, residueId)
        self.groupId = _cast(None, groupId)
        self.unit = _cast(None, unit)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if propertyType.subclass:
            return propertyType.subclass(*args_, **kwargs_)
        else:
            return propertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_moleculeId(self): return self.moleculeId
    def set_moleculeId(self, moleculeId): self.moleculeId = moleculeId
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_propertyCount(self): return self.propertyCount
    def set_propertyCount(self, propertyCount): self.propertyCount = propertyCount
    def get_atomId(self): return self.atomId
    def set_atomId(self, atomId): self.atomId = atomId
    def get_residueId(self): return self.residueId
    def set_residueId(self, residueId): self.residueId = residueId
    def get_groupId(self): return self.groupId
    def set_groupId(self, groupId): self.groupId = groupId
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_numerictypeType(self, value):
        # Validate type numerictypeType, a restriction on xs:string.
        pass
    def hasContent_(self):
        return True
    def export(self, outfile, level, namespace_='cs:', name_='propertyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='propertyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='propertyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='propertyType'):
        if self.moleculeId is not None and 'moleculeId' not in already_processed:
            already_processed.add('moleculeId')
            outfile.write(' moleculeId=%s' % (self.gds_format_string(quote_attrib(self.moleculeId).encode(ExternalEncoding), input_name='moleculeId'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
        if self.propertyCount is not None and 'propertyCount' not in already_processed:
            already_processed.add('propertyCount')
            outfile.write(' propertyCount="%s"' % self.gds_format_integer(self.propertyCount, input_name='propertyCount'))
        if self.atomId is not None and 'atomId' not in already_processed:
            already_processed.add('atomId')
            outfile.write(' atomId=%s' % (self.gds_format_string(quote_attrib(self.atomId).encode(ExternalEncoding), input_name='atomId'), ))
        if self.residueId is not None and 'residueId' not in already_processed:
            already_processed.add('residueId')
            outfile.write(' residueId=%s' % (self.gds_format_string(quote_attrib(self.residueId).encode(ExternalEncoding), input_name='residueId'), ))
        if self.groupId is not None and 'groupId' not in already_processed:
            already_processed.add('groupId')
            outfile.write(' groupId=%s' % (self.gds_format_string(quote_attrib(self.groupId).encode(ExternalEncoding), input_name='groupId'), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_format_string(quote_attrib(self.unit).encode(ExternalEncoding), input_name='unit'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='propertyType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='propertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.moleculeId is not None and 'moleculeId' not in already_processed:
            already_processed.add('moleculeId')
            showIndent(outfile, level)
            outfile.write('moleculeId="%s",\n' % (self.moleculeId,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype="%s",\n' % (self.datatype,))
        if self.propertyCount is not None and 'propertyCount' not in already_processed:
            already_processed.add('propertyCount')
            showIndent(outfile, level)
            outfile.write('propertyCount=%d,\n' % (self.propertyCount,))
        if self.atomId is not None and 'atomId' not in already_processed:
            already_processed.add('atomId')
            showIndent(outfile, level)
            outfile.write('atomId="%s",\n' % (self.atomId,))
        if self.residueId is not None and 'residueId' not in already_processed:
            already_processed.add('residueId')
            showIndent(outfile, level)
            outfile.write('residueId="%s",\n' % (self.residueId,))
        if self.groupId is not None and 'groupId' not in already_processed:
            already_processed.add('groupId')
            showIndent(outfile, level)
            outfile.write('groupId="%s",\n' % (self.groupId,))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('moleculeId', node)
        if value is not None and 'moleculeId' not in already_processed:
            already_processed.add('moleculeId')
            self.moleculeId = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_numerictypeType(self.datatype)    # validate type numerictypeType
        value = find_attr_value_('propertyCount', node)
        if value is not None and 'propertyCount' not in already_processed:
            already_processed.add('propertyCount')
            try:
                self.propertyCount = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.propertyCount <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('atomId', node)
        if value is not None and 'atomId' not in already_processed:
            already_processed.add('atomId')
            self.atomId = value
        value = find_attr_value_('residueId', node)
        if value is not None and 'residueId' not in already_processed:
            already_processed.add('residueId')
            self.residueId = value
        value = find_attr_value_('groupId', node)
        if value is not None and 'groupId' not in already_processed:
            already_processed.add('groupId')
            self.groupId = value
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class propertyType


class waveFunctionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, orbitalCount=None, basisCount=None, orbitalEnergies=None, orbitalSymmetry=None, orbitalOccupancies=None, orbitals=None, alphaOrbitalEnergies=None, alphaOrbitalSymmetry=None, alphaOrbitalOccupancies=None, alphaOrbitals=None, betaOrbitalEnergies=None, betaOrbitalSymmetry=None, betaOrbitalOccupancies=None, betaOrbitals=None):
        self.original_tagname_ = None
        self.orbitalCount = _cast(int, orbitalCount)
        self.basisCount = _cast(int, basisCount)
        self.orbitalEnergies = orbitalEnergies
        self.orbitalSymmetry = orbitalSymmetry
        self.orbitalOccupancies = orbitalOccupancies
        self.orbitals = orbitals
        self.alphaOrbitalEnergies = alphaOrbitalEnergies
        self.alphaOrbitalSymmetry = alphaOrbitalSymmetry
        self.alphaOrbitalOccupancies = alphaOrbitalOccupancies
        self.alphaOrbitals = alphaOrbitals
        self.betaOrbitalEnergies = betaOrbitalEnergies
        self.betaOrbitalSymmetry = betaOrbitalSymmetry
        self.betaOrbitalOccupancies = betaOrbitalOccupancies
        self.betaOrbitals = betaOrbitals
    def factory(*args_, **kwargs_):
        if waveFunctionType.subclass:
            return waveFunctionType.subclass(*args_, **kwargs_)
        else:
            return waveFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_orbitalEnergies(self): return self.orbitalEnergies
    def set_orbitalEnergies(self, orbitalEnergies): self.orbitalEnergies = orbitalEnergies
    def get_orbitalSymmetry(self): return self.orbitalSymmetry
    def set_orbitalSymmetry(self, orbitalSymmetry): self.orbitalSymmetry = orbitalSymmetry
    def get_orbitalOccupancies(self): return self.orbitalOccupancies
    def set_orbitalOccupancies(self, orbitalOccupancies): self.orbitalOccupancies = orbitalOccupancies
    def get_orbitals(self): return self.orbitals
    def set_orbitals(self, orbitals): self.orbitals = orbitals
    def get_alphaOrbitalEnergies(self): return self.alphaOrbitalEnergies
    def set_alphaOrbitalEnergies(self, alphaOrbitalEnergies): self.alphaOrbitalEnergies = alphaOrbitalEnergies
    def get_alphaOrbitalSymmetry(self): return self.alphaOrbitalSymmetry
    def set_alphaOrbitalSymmetry(self, alphaOrbitalSymmetry): self.alphaOrbitalSymmetry = alphaOrbitalSymmetry
    def get_alphaOrbitalOccupancies(self): return self.alphaOrbitalOccupancies
    def set_alphaOrbitalOccupancies(self, alphaOrbitalOccupancies): self.alphaOrbitalOccupancies = alphaOrbitalOccupancies
    def get_alphaOrbitals(self): return self.alphaOrbitals
    def set_alphaOrbitals(self, alphaOrbitals): self.alphaOrbitals = alphaOrbitals
    def get_betaOrbitalEnergies(self): return self.betaOrbitalEnergies
    def set_betaOrbitalEnergies(self, betaOrbitalEnergies): self.betaOrbitalEnergies = betaOrbitalEnergies
    def get_betaOrbitalSymmetry(self): return self.betaOrbitalSymmetry
    def set_betaOrbitalSymmetry(self, betaOrbitalSymmetry): self.betaOrbitalSymmetry = betaOrbitalSymmetry
    def get_betaOrbitalOccupancies(self): return self.betaOrbitalOccupancies
    def set_betaOrbitalOccupancies(self, betaOrbitalOccupancies): self.betaOrbitalOccupancies = betaOrbitalOccupancies
    def get_betaOrbitals(self): return self.betaOrbitals
    def set_betaOrbitals(self, betaOrbitals): self.betaOrbitals = betaOrbitals
    def get_orbitalCount(self): return self.orbitalCount
    def set_orbitalCount(self, orbitalCount): self.orbitalCount = orbitalCount
    def get_basisCount(self): return self.basisCount
    def set_basisCount(self, basisCount): self.basisCount = basisCount
    def hasContent_(self):
        if (
            self.orbitalEnergies is not None or
            self.orbitalSymmetry is not None or
            self.orbitalOccupancies is not None or
            self.orbitals is not None or
            self.alphaOrbitalEnergies is not None or
            self.alphaOrbitalSymmetry is not None or
            self.alphaOrbitalOccupancies is not None or
            self.alphaOrbitals is not None or
            self.betaOrbitalEnergies is not None or
            self.betaOrbitalSymmetry is not None or
            self.betaOrbitalOccupancies is not None or
            self.betaOrbitals is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='waveFunctionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='waveFunctionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='waveFunctionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='waveFunctionType'):
        if self.orbitalCount is not None and 'orbitalCount' not in already_processed:
            already_processed.add('orbitalCount')
            outfile.write(' orbitalCount="%s"' % self.gds_format_integer(self.orbitalCount, input_name='orbitalCount'))
        if self.basisCount is not None and 'basisCount' not in already_processed:
            already_processed.add('basisCount')
            outfile.write(' basisCount="%s"' % self.gds_format_integer(self.basisCount, input_name='basisCount'))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='waveFunctionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orbitalEnergies is not None:
            self.orbitalEnergies.export(outfile, level, namespace_, name_='orbitalEnergies', pretty_print=pretty_print)
        if self.orbitalSymmetry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorbitalSymmetry>%s</%sorbitalSymmetry>%s' % (namespace_, self.gds_format_string(quote_xml(self.orbitalSymmetry).encode(ExternalEncoding), input_name='orbitalSymmetry'), namespace_, eol_))
        if self.orbitalOccupancies is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorbitalOccupancies>%s</%sorbitalOccupancies>%s' % (namespace_, self.gds_format_string(quote_xml(self.orbitalOccupancies).encode(ExternalEncoding), input_name='orbitalOccupancies'), namespace_, eol_))
        if self.orbitals is not None:
            self.orbitals.export(outfile, level, namespace_, name_='orbitals', pretty_print=pretty_print)
        if self.alphaOrbitalEnergies is not None:
            self.alphaOrbitalEnergies.export(outfile, level, namespace_, name_='alphaOrbitalEnergies', pretty_print=pretty_print)
        if self.alphaOrbitalSymmetry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%salphaOrbitalSymmetry>%s</%salphaOrbitalSymmetry>%s' % (namespace_, self.gds_format_string(quote_xml(self.alphaOrbitalSymmetry).encode(ExternalEncoding), input_name='alphaOrbitalSymmetry'), namespace_, eol_))
        if self.alphaOrbitalOccupancies is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%salphaOrbitalOccupancies>%s</%salphaOrbitalOccupancies>%s' % (namespace_, self.gds_format_string(quote_xml(self.alphaOrbitalOccupancies).encode(ExternalEncoding), input_name='alphaOrbitalOccupancies'), namespace_, eol_))
        if self.alphaOrbitals is not None:
            self.alphaOrbitals.export(outfile, level, namespace_, name_='alphaOrbitals', pretty_print=pretty_print)
        if self.betaOrbitalEnergies is not None:
            self.betaOrbitalEnergies.export(outfile, level, namespace_, name_='betaOrbitalEnergies', pretty_print=pretty_print)
        if self.betaOrbitalSymmetry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbetaOrbitalSymmetry>%s</%sbetaOrbitalSymmetry>%s' % (namespace_, self.gds_format_string(quote_xml(self.betaOrbitalSymmetry).encode(ExternalEncoding), input_name='betaOrbitalSymmetry'), namespace_, eol_))
        if self.betaOrbitalOccupancies is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbetaOrbitalOccupancies>%s</%sbetaOrbitalOccupancies>%s' % (namespace_, self.gds_format_string(quote_xml(self.betaOrbitalOccupancies).encode(ExternalEncoding), input_name='betaOrbitalOccupancies'), namespace_, eol_))
        if self.betaOrbitals is not None:
            self.betaOrbitals.export(outfile, level, namespace_, name_='betaOrbitals', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='waveFunctionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.orbitalCount is not None and 'orbitalCount' not in already_processed:
            already_processed.add('orbitalCount')
            showIndent(outfile, level)
            outfile.write('orbitalCount=%d,\n' % (self.orbitalCount,))
        if self.basisCount is not None and 'basisCount' not in already_processed:
            already_processed.add('basisCount')
            showIndent(outfile, level)
            outfile.write('basisCount=%d,\n' % (self.basisCount,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.orbitalEnergies is not None:
            showIndent(outfile, level)
            outfile.write('orbitalEnergies=model_.stringArrayType(\n')
            self.orbitalEnergies.exportLiteral(outfile, level, name_='orbitalEnergies')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.orbitalSymmetry is not None:
            showIndent(outfile, level)
            outfile.write('orbitalSymmetry=%s,\n' % quote_python(self.orbitalSymmetry).encode(ExternalEncoding))
        if self.orbitalOccupancies is not None:
            showIndent(outfile, level)
            outfile.write('orbitalOccupancies=%s,\n' % quote_python(self.orbitalOccupancies).encode(ExternalEncoding))
        if self.orbitals is not None:
            showIndent(outfile, level)
            outfile.write('orbitals=model_.orbitalsType(\n')
            self.orbitals.exportLiteral(outfile, level, name_='orbitals')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.alphaOrbitalEnergies is not None:
            showIndent(outfile, level)
            outfile.write('alphaOrbitalEnergies=model_.stringArrayType(\n')
            self.alphaOrbitalEnergies.exportLiteral(outfile, level, name_='alphaOrbitalEnergies')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.alphaOrbitalSymmetry is not None:
            showIndent(outfile, level)
            outfile.write('alphaOrbitalSymmetry=%s,\n' % quote_python(self.alphaOrbitalSymmetry).encode(ExternalEncoding))
        if self.alphaOrbitalOccupancies is not None:
            showIndent(outfile, level)
            outfile.write('alphaOrbitalOccupancies=%s,\n' % quote_python(self.alphaOrbitalOccupancies).encode(ExternalEncoding))
        if self.alphaOrbitals is not None:
            showIndent(outfile, level)
            outfile.write('alphaOrbitals=model_.orbitalsType(\n')
            self.alphaOrbitals.exportLiteral(outfile, level, name_='alphaOrbitals')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.betaOrbitalEnergies is not None:
            showIndent(outfile, level)
            outfile.write('betaOrbitalEnergies=model_.stringArrayType(\n')
            self.betaOrbitalEnergies.exportLiteral(outfile, level, name_='betaOrbitalEnergies')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.betaOrbitalSymmetry is not None:
            showIndent(outfile, level)
            outfile.write('betaOrbitalSymmetry=%s,\n' % quote_python(self.betaOrbitalSymmetry).encode(ExternalEncoding))
        if self.betaOrbitalOccupancies is not None:
            showIndent(outfile, level)
            outfile.write('betaOrbitalOccupancies=%s,\n' % quote_python(self.betaOrbitalOccupancies).encode(ExternalEncoding))
        if self.betaOrbitals is not None:
            showIndent(outfile, level)
            outfile.write('betaOrbitals=model_.orbitalsType(\n')
            self.betaOrbitals.exportLiteral(outfile, level, name_='betaOrbitals')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('orbitalCount', node)
        if value is not None and 'orbitalCount' not in already_processed:
            already_processed.add('orbitalCount')
            try:
                self.orbitalCount = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.orbitalCount <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('basisCount', node)
        if value is not None and 'basisCount' not in already_processed:
            already_processed.add('basisCount')
            try:
                self.basisCount = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.basisCount <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orbitalEnergies':
            obj_ = stringArrayType.factory()
            obj_.build(child_)
            self.orbitalEnergies = obj_
            obj_.original_tagname_ = 'orbitalEnergies'
        elif nodeName_ == 'orbitalSymmetry':
            orbitalSymmetry_ = child_.text
            orbitalSymmetry_ = self.gds_validate_string(orbitalSymmetry_, node, 'orbitalSymmetry')
            self.orbitalSymmetry = orbitalSymmetry_
        elif nodeName_ == 'orbitalOccupancies':
            orbitalOccupancies_ = child_.text
            orbitalOccupancies_ = self.gds_validate_string(orbitalOccupancies_, node, 'orbitalOccupancies')
            self.orbitalOccupancies = orbitalOccupancies_
        elif nodeName_ == 'orbitals':
            obj_ = orbitalsType.factory()
            obj_.build(child_)
            self.orbitals = obj_
            obj_.original_tagname_ = 'orbitals'
        elif nodeName_ == 'alphaOrbitalEnergies':
            obj_ = stringArrayType.factory()
            obj_.build(child_)
            self.alphaOrbitalEnergies = obj_
            obj_.original_tagname_ = 'alphaOrbitalEnergies'
        elif nodeName_ == 'alphaOrbitalSymmetry':
            alphaOrbitalSymmetry_ = child_.text
            alphaOrbitalSymmetry_ = self.gds_validate_string(alphaOrbitalSymmetry_, node, 'alphaOrbitalSymmetry')
            self.alphaOrbitalSymmetry = alphaOrbitalSymmetry_
        elif nodeName_ == 'alphaOrbitalOccupancies':
            alphaOrbitalOccupancies_ = child_.text
            alphaOrbitalOccupancies_ = self.gds_validate_string(alphaOrbitalOccupancies_, node, 'alphaOrbitalOccupancies')
            self.alphaOrbitalOccupancies = alphaOrbitalOccupancies_
        elif nodeName_ == 'alphaOrbitals':
            obj_ = orbitalsType.factory()
            obj_.build(child_)
            self.alphaOrbitals = obj_
            obj_.original_tagname_ = 'alphaOrbitals'
        elif nodeName_ == 'betaOrbitalEnergies':
            obj_ = stringArrayType.factory()
            obj_.build(child_)
            self.betaOrbitalEnergies = obj_
            obj_.original_tagname_ = 'betaOrbitalEnergies'
        elif nodeName_ == 'betaOrbitalSymmetry':
            betaOrbitalSymmetry_ = child_.text
            betaOrbitalSymmetry_ = self.gds_validate_string(betaOrbitalSymmetry_, node, 'betaOrbitalSymmetry')
            self.betaOrbitalSymmetry = betaOrbitalSymmetry_
        elif nodeName_ == 'betaOrbitalOccupancies':
            betaOrbitalOccupancies_ = child_.text
            betaOrbitalOccupancies_ = self.gds_validate_string(betaOrbitalOccupancies_, node, 'betaOrbitalOccupancies')
            self.betaOrbitalOccupancies = betaOrbitalOccupancies_
        elif nodeName_ == 'betaOrbitals':
            obj_ = orbitalsType.factory()
            obj_.build(child_)
            self.betaOrbitals = obj_
            obj_.original_tagname_ = 'betaOrbitals'
# end class waveFunctionType


class orbitalsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, orbital=None):
        self.original_tagname_ = None
        if orbital is None:
            self.orbital = []
        else:
            self.orbital = orbital
    def factory(*args_, **kwargs_):
        if orbitalsType.subclass:
            return orbitalsType.subclass(*args_, **kwargs_)
        else:
            return orbitalsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_orbital(self): return self.orbital
    def set_orbital(self, orbital): self.orbital = orbital
    def add_orbital(self, value): self.orbital.append(value)
    def insert_orbital_at(self, index, value): self.orbital.insert(index, value)
    def replace_orbital_at(self, index, value): self.orbital[index] = value
    def hasContent_(self):
        if (
            self.orbital
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='orbitalsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='orbitalsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='orbitalsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='orbitalsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='orbitalsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for orbital_ in self.orbital:
            orbital_.export(outfile, level, namespace_, name_='orbital', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='orbitalsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('orbital=[\n')
        level += 1
        for orbital_ in self.orbital:
            showIndent(outfile, level)
            outfile.write('model_.stringArrayType(\n')
            orbital_.exportLiteral(outfile, level, name_='stringArrayType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orbital':
            obj_ = stringArrayType.factory()
            obj_.build(child_)
            self.orbital.append(obj_)
            obj_.original_tagname_ = 'orbital'
# end class orbitalsType


class vibAnalysisType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vibrationCount=None, frequencies=None, irreducibleRepresentation=None, irIntensities=None, ramanIntensities=None, normalModeSymmetry=None, normalModes=None):
        self.original_tagname_ = None
        self.vibrationCount = _cast(int, vibrationCount)
        self.frequencies = frequencies
        self.irreducibleRepresentation = irreducibleRepresentation
        self.irIntensities = irIntensities
        self.ramanIntensities = ramanIntensities
        self.normalModeSymmetry = normalModeSymmetry
        self.normalModes = normalModes
    def factory(*args_, **kwargs_):
        if vibAnalysisType.subclass:
            return vibAnalysisType.subclass(*args_, **kwargs_)
        else:
            return vibAnalysisType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_frequencies(self): return self.frequencies
    def set_frequencies(self, frequencies): self.frequencies = frequencies
    def get_irreducibleRepresentation(self): return self.irreducibleRepresentation
    def set_irreducibleRepresentation(self, irreducibleRepresentation): self.irreducibleRepresentation = irreducibleRepresentation
    def get_irIntensities(self): return self.irIntensities
    def set_irIntensities(self, irIntensities): self.irIntensities = irIntensities
    def get_ramanIntensities(self): return self.ramanIntensities
    def set_ramanIntensities(self, ramanIntensities): self.ramanIntensities = ramanIntensities
    def get_normalModeSymmetry(self): return self.normalModeSymmetry
    def set_normalModeSymmetry(self, normalModeSymmetry): self.normalModeSymmetry = normalModeSymmetry
    def get_normalModes(self): return self.normalModes
    def set_normalModes(self, normalModes): self.normalModes = normalModes
    def get_vibrationCount(self): return self.vibrationCount
    def set_vibrationCount(self, vibrationCount): self.vibrationCount = vibrationCount
    def hasContent_(self):
        if (
            self.frequencies is not None or
            self.irreducibleRepresentation is not None or
            self.irIntensities is not None or
            self.ramanIntensities is not None or
            self.normalModeSymmetry is not None or
            self.normalModes is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='vibAnalysisType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vibAnalysisType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='vibAnalysisType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='vibAnalysisType'):
        if self.vibrationCount is not None and 'vibrationCount' not in already_processed:
            already_processed.add('vibrationCount')
            outfile.write(' vibrationCount="%s"' % self.gds_format_integer(self.vibrationCount, input_name='vibrationCount'))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='vibAnalysisType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.frequencies is not None:
            self.frequencies.export(outfile, level, namespace_, name_='frequencies', pretty_print=pretty_print)
        if self.irreducibleRepresentation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sirreducibleRepresentation>%s</%sirreducibleRepresentation>%s' % (namespace_, self.gds_format_string(quote_xml(self.irreducibleRepresentation).encode(ExternalEncoding), input_name='irreducibleRepresentation'), namespace_, eol_))
        if self.irIntensities is not None:
            self.irIntensities.export(outfile, level, namespace_, name_='irIntensities', pretty_print=pretty_print)
        if self.ramanIntensities is not None:
            self.ramanIntensities.export(outfile, level, namespace_, name_='ramanIntensities', pretty_print=pretty_print)
        if self.normalModeSymmetry is not None:
            self.normalModeSymmetry.export(outfile, level, namespace_, name_='normalModeSymmetry', pretty_print=pretty_print)
        if self.normalModes is not None:
            self.normalModes.export(outfile, level, namespace_, name_='normalModes', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='vibAnalysisType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vibrationCount is not None and 'vibrationCount' not in already_processed:
            already_processed.add('vibrationCount')
            showIndent(outfile, level)
            outfile.write('vibrationCount=%d,\n' % (self.vibrationCount,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.frequencies is not None:
            showIndent(outfile, level)
            outfile.write('frequencies=model_.stringArrayType(\n')
            self.frequencies.exportLiteral(outfile, level, name_='frequencies')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.irreducibleRepresentation is not None:
            showIndent(outfile, level)
            outfile.write('irreducibleRepresentation=%s,\n' % quote_python(self.irreducibleRepresentation).encode(ExternalEncoding))
        if self.irIntensities is not None:
            showIndent(outfile, level)
            outfile.write('irIntensities=model_.stringArrayType(\n')
            self.irIntensities.exportLiteral(outfile, level, name_='irIntensities')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ramanIntensities is not None:
            showIndent(outfile, level)
            outfile.write('ramanIntensities=model_.stringArrayType(\n')
            self.ramanIntensities.exportLiteral(outfile, level, name_='ramanIntensities')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.normalModeSymmetry is not None:
            showIndent(outfile, level)
            outfile.write('normalModeSymmetry=model_.stringArrayType(\n')
            self.normalModeSymmetry.exportLiteral(outfile, level, name_='normalModeSymmetry')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.normalModes is not None:
            showIndent(outfile, level)
            outfile.write('normalModes=model_.normalModesType(\n')
            self.normalModes.exportLiteral(outfile, level, name_='normalModes')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vibrationCount', node)
        if value is not None and 'vibrationCount' not in already_processed:
            already_processed.add('vibrationCount')
            try:
                self.vibrationCount = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.vibrationCount <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'frequencies':
            obj_ = stringArrayType.factory()
            obj_.build(child_)
            self.frequencies = obj_
            obj_.original_tagname_ = 'frequencies'
        elif nodeName_ == 'irreducibleRepresentation':
            irreducibleRepresentation_ = child_.text
            irreducibleRepresentation_ = self.gds_validate_string(irreducibleRepresentation_, node, 'irreducibleRepresentation')
            self.irreducibleRepresentation = irreducibleRepresentation_
        elif nodeName_ == 'irIntensities':
            obj_ = stringArrayType.factory()
            obj_.build(child_)
            self.irIntensities = obj_
            obj_.original_tagname_ = 'irIntensities'
        elif nodeName_ == 'ramanIntensities':
            obj_ = stringArrayType.factory()
            obj_.build(child_)
            self.ramanIntensities = obj_
            obj_.original_tagname_ = 'ramanIntensities'
        elif nodeName_ == 'normalModeSymmetry':
            obj_ = stringArrayType.factory()
            obj_.build(child_)
            self.normalModeSymmetry = obj_
            obj_.original_tagname_ = 'normalModeSymmetry'
        elif nodeName_ == 'normalModes':
            obj_ = normalModesType.factory()
            obj_.build(child_)
            self.normalModes = obj_
            obj_.original_tagname_ = 'normalModes'
# end class vibAnalysisType


class normalModesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, normalMode=None):
        self.original_tagname_ = None
        if normalMode is None:
            self.normalMode = []
        else:
            self.normalMode = normalMode
    def factory(*args_, **kwargs_):
        if normalModesType.subclass:
            return normalModesType.subclass(*args_, **kwargs_)
        else:
            return normalModesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_normalMode(self): return self.normalMode
    def set_normalMode(self, normalMode): self.normalMode = normalMode
    def add_normalMode(self, value): self.normalMode.append(value)
    def insert_normalMode_at(self, index, value): self.normalMode.insert(index, value)
    def replace_normalMode_at(self, index, value): self.normalMode[index] = value
    def hasContent_(self):
        if (
            self.normalMode
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='normalModesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='normalModesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='normalModesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='normalModesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='normalModesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for normalMode_ in self.normalMode:
            normalMode_.export(outfile, level, namespace_, name_='normalMode', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='normalModesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('normalMode=[\n')
        level += 1
        for normalMode_ in self.normalMode:
            showIndent(outfile, level)
            outfile.write('model_.normalModeType(\n')
            normalMode_.exportLiteral(outfile, level, name_='normalModeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'normalMode':
            obj_ = normalModeType.factory()
            obj_.build(child_)
            self.normalMode.append(obj_)
            obj_.original_tagname_ = 'normalMode'
# end class normalModesType


class normalModeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(int, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if normalModeType.subclass:
            return normalModeType.subclass(*args_, **kwargs_)
        else:
            return normalModeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='normalModeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='normalModeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='normalModeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='normalModeType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='normalModeType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='normalModeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%d,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            try:
                self.id = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class normalModeType


class elecSpectraType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ciOccupiedOrbitalsIncluded=None, transitionCount=None, ciUnoccupiedOrbitalsIncluded=None, excitedStateMethod=None, unit=None, electronicTransitions=None, oscillatorStrength=None):
        self.original_tagname_ = None
        self.ciOccupiedOrbitalsIncluded = _cast(int, ciOccupiedOrbitalsIncluded)
        self.transitionCount = _cast(int, transitionCount)
        self.ciUnoccupiedOrbitalsIncluded = _cast(int, ciUnoccupiedOrbitalsIncluded)
        self.excitedStateMethod = _cast(None, excitedStateMethod)
        self.unit = _cast(None, unit)
        self.electronicTransitions = electronicTransitions
        self.oscillatorStrength = oscillatorStrength
    def factory(*args_, **kwargs_):
        if elecSpectraType.subclass:
            return elecSpectraType.subclass(*args_, **kwargs_)
        else:
            return elecSpectraType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_electronicTransitions(self): return self.electronicTransitions
    def set_electronicTransitions(self, electronicTransitions): self.electronicTransitions = electronicTransitions
    def get_oscillatorStrength(self): return self.oscillatorStrength
    def set_oscillatorStrength(self, oscillatorStrength): self.oscillatorStrength = oscillatorStrength
    def get_ciOccupiedOrbitalsIncluded(self): return self.ciOccupiedOrbitalsIncluded
    def set_ciOccupiedOrbitalsIncluded(self, ciOccupiedOrbitalsIncluded): self.ciOccupiedOrbitalsIncluded = ciOccupiedOrbitalsIncluded
    def get_transitionCount(self): return self.transitionCount
    def set_transitionCount(self, transitionCount): self.transitionCount = transitionCount
    def get_ciUnoccupiedOrbitalsIncluded(self): return self.ciUnoccupiedOrbitalsIncluded
    def set_ciUnoccupiedOrbitalsIncluded(self, ciUnoccupiedOrbitalsIncluded): self.ciUnoccupiedOrbitalsIncluded = ciUnoccupiedOrbitalsIncluded
    def get_excitedStateMethod(self): return self.excitedStateMethod
    def set_excitedStateMethod(self, excitedStateMethod): self.excitedStateMethod = excitedStateMethod
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def validate_excitedStateMethodType(self, value):
        # Validate type excitedStateMethodType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.electronicTransitions is not None or
            self.oscillatorStrength is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='elecSpectraType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='elecSpectraType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='elecSpectraType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='elecSpectraType'):
        if self.ciOccupiedOrbitalsIncluded is not None and 'ciOccupiedOrbitalsIncluded' not in already_processed:
            already_processed.add('ciOccupiedOrbitalsIncluded')
            outfile.write(' ciOccupiedOrbitalsIncluded="%s"' % self.gds_format_integer(self.ciOccupiedOrbitalsIncluded, input_name='ciOccupiedOrbitalsIncluded'))
        if self.transitionCount is not None and 'transitionCount' not in already_processed:
            already_processed.add('transitionCount')
            outfile.write(' transitionCount="%s"' % self.gds_format_integer(self.transitionCount, input_name='transitionCount'))
        if self.ciUnoccupiedOrbitalsIncluded is not None and 'ciUnoccupiedOrbitalsIncluded' not in already_processed:
            already_processed.add('ciUnoccupiedOrbitalsIncluded')
            outfile.write(' ciUnoccupiedOrbitalsIncluded="%s"' % self.gds_format_integer(self.ciUnoccupiedOrbitalsIncluded, input_name='ciUnoccupiedOrbitalsIncluded'))
        if self.excitedStateMethod is not None and 'excitedStateMethod' not in already_processed:
            already_processed.add('excitedStateMethod')
            outfile.write(' excitedStateMethod=%s' % (quote_attrib(self.excitedStateMethod), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_format_string(quote_attrib(self.unit).encode(ExternalEncoding), input_name='unit'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='elecSpectraType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.electronicTransitions is not None:
            self.electronicTransitions.export(outfile, level, namespace_, name_='electronicTransitions', pretty_print=pretty_print)
        if self.oscillatorStrength is not None:
            self.oscillatorStrength.export(outfile, level, namespace_, name_='oscillatorStrength', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='elecSpectraType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ciOccupiedOrbitalsIncluded is not None and 'ciOccupiedOrbitalsIncluded' not in already_processed:
            already_processed.add('ciOccupiedOrbitalsIncluded')
            showIndent(outfile, level)
            outfile.write('ciOccupiedOrbitalsIncluded=%d,\n' % (self.ciOccupiedOrbitalsIncluded,))
        if self.transitionCount is not None and 'transitionCount' not in already_processed:
            already_processed.add('transitionCount')
            showIndent(outfile, level)
            outfile.write('transitionCount=%d,\n' % (self.transitionCount,))
        if self.ciUnoccupiedOrbitalsIncluded is not None and 'ciUnoccupiedOrbitalsIncluded' not in already_processed:
            already_processed.add('ciUnoccupiedOrbitalsIncluded')
            showIndent(outfile, level)
            outfile.write('ciUnoccupiedOrbitalsIncluded=%d,\n' % (self.ciUnoccupiedOrbitalsIncluded,))
        if self.excitedStateMethod is not None and 'excitedStateMethod' not in already_processed:
            already_processed.add('excitedStateMethod')
            showIndent(outfile, level)
            outfile.write('excitedStateMethod="%s",\n' % (self.excitedStateMethod,))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.electronicTransitions is not None:
            showIndent(outfile, level)
            outfile.write('electronicTransitions=model_.stringArrayType(\n')
            self.electronicTransitions.exportLiteral(outfile, level, name_='electronicTransitions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.oscillatorStrength is not None:
            showIndent(outfile, level)
            outfile.write('oscillatorStrength=model_.stringArrayType(\n')
            self.oscillatorStrength.exportLiteral(outfile, level, name_='oscillatorStrength')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ciOccupiedOrbitalsIncluded', node)
        if value is not None and 'ciOccupiedOrbitalsIncluded' not in already_processed:
            already_processed.add('ciOccupiedOrbitalsIncluded')
            try:
                self.ciOccupiedOrbitalsIncluded = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ciOccupiedOrbitalsIncluded <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('transitionCount', node)
        if value is not None and 'transitionCount' not in already_processed:
            already_processed.add('transitionCount')
            try:
                self.transitionCount = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.transitionCount <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('ciUnoccupiedOrbitalsIncluded', node)
        if value is not None and 'ciUnoccupiedOrbitalsIncluded' not in already_processed:
            already_processed.add('ciUnoccupiedOrbitalsIncluded')
            try:
                self.ciUnoccupiedOrbitalsIncluded = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.ciUnoccupiedOrbitalsIncluded <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('excitedStateMethod', node)
        if value is not None and 'excitedStateMethod' not in already_processed:
            already_processed.add('excitedStateMethod')
            self.excitedStateMethod = value
            self.validate_excitedStateMethodType(self.excitedStateMethod)    # validate type excitedStateMethodType
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'electronicTransitions':
            obj_ = stringArrayType.factory()
            obj_.build(child_)
            self.electronicTransitions = obj_
            obj_.original_tagname_ = 'electronicTransitions'
        elif nodeName_ == 'oscillatorStrength':
            obj_ = stringArrayType.factory()
            obj_.build(child_)
            self.oscillatorStrength = obj_
            obj_.original_tagname_ = 'oscillatorStrength'
# end class elecSpectraType


class conditionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, name=None, unit=None, valueOf_=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.name = _cast(None, name)
        self.unit = _cast(None, unit)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if conditionType.subclass:
            return conditionType.subclass(*args_, **kwargs_)
        else:
            return conditionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_dataType(self, value):
        # Validate type dataType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='conditionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='conditionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='conditionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='conditionType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_format_string(quote_attrib(self.unit).encode(ExternalEncoding), input_name='unit'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='conditionType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='conditionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_=%s,\n' % (self.type_,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_dataType(self.type_)    # validate type dataType
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class conditionType


class stringArrayType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, datatype=None, id=None, unit=None, valueOf_=None):
        self.original_tagname_ = None
        self.datatype = _cast(None, datatype)
        self.id = _cast(None, id)
        self.unit = _cast(None, unit)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if stringArrayType.subclass:
            return stringArrayType.subclass(*args_, **kwargs_)
        else:
            return stringArrayType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_stringarraydatatypeType(self, value):
        # Validate type stringarraydatatypeType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='stringArrayType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='stringArrayType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='stringArrayType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='stringArrayType'):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_format_string(quote_attrib(self.unit).encode(ExternalEncoding), input_name='unit'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='stringArrayType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='stringArrayType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype="%s",\n' % (self.datatype,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
            self.validate_stringarraydatatypeType(self.datatype)    # validate type stringarraydatatypeType
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class stringArrayType


class title(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if title.subclass:
            return title.subclass(*args_, **kwargs_)
        else:
            return title(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='title', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='title')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='title', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='title'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='title', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='title'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class title


class creator(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if creator.subclass:
            return creator.subclass(*args_, **kwargs_)
        else:
            return creator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='creator', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='creator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='creator', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='creator'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='creator', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='creator'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class creator


class subject(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if subject.subclass:
            return subject.subclass(*args_, **kwargs_)
        else:
            return subject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='subject', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='subject')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='subject', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='subject'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='subject', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='subject'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class subject


class description(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if description.subclass:
            return description.subclass(*args_, **kwargs_)
        else:
            return description(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='description', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='description')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='description', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='description'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='description', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='description'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class description


class publisher(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if publisher.subclass:
            return publisher.subclass(*args_, **kwargs_)
        else:
            return publisher(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='publisher', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='publisher')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='publisher', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='publisher'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='publisher', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='publisher'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class publisher


class contributor(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if contributor.subclass:
            return contributor.subclass(*args_, **kwargs_)
        else:
            return contributor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='contributor', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='contributor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='contributor', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='contributor'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='contributor', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='contributor'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class contributor


class date(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if date.subclass:
            return date.subclass(*args_, **kwargs_)
        else:
            return date(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='date', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='date')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='date', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='date'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='date', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='date'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class date


class type_(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if type_.subclass:
            return type_.subclass(*args_, **kwargs_)
        else:
            return type_(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='type'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class type_


class format(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if format.subclass:
            return format.subclass(*args_, **kwargs_)
        else:
            return format(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='format', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='format')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='format', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='format'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='format', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='format'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class format


class identifier(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if identifier.subclass:
            return identifier.subclass(*args_, **kwargs_)
        else:
            return identifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='identifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='identifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='identifier', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='identifier'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='identifier', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='identifier'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class identifier


class source(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if source.subclass:
            return source.subclass(*args_, **kwargs_)
        else:
            return source(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='source', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='source')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='source', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='source'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='source', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='source'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class source


class language(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if language.subclass:
            return language.subclass(*args_, **kwargs_)
        else:
            return language(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='language', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='language')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='language', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='language'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='language', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='language'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class language


class relation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if relation.subclass:
            return relation.subclass(*args_, **kwargs_)
        else:
            return relation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='relation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='relation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='relation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='relation'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='relation', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='relation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class relation


class coverage(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if coverage.subclass:
            return coverage.subclass(*args_, **kwargs_)
        else:
            return coverage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='coverage', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='coverage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='coverage', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='coverage'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='coverage', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='coverage'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class coverage


class rights(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if rights.subclass:
            return rights.subclass(*args_, **kwargs_)
        else:
            return rights(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='rights', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rights')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='rights', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='rights'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='rights', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='rights'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class rights


class alternative(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if alternative.subclass:
            return alternative.subclass(*args_, **kwargs_)
        else:
            return alternative(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='alternative', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='alternative')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='alternative', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='alternative'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='alternative', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='alternative'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class alternative


class tableOfContents(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if tableOfContents.subclass:
            return tableOfContents.subclass(*args_, **kwargs_)
        else:
            return tableOfContents(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='tableOfContents', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tableOfContents')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='tableOfContents', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='tableOfContents'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='tableOfContents', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='tableOfContents'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tableOfContents


class abstract(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if abstract.subclass:
            return abstract.subclass(*args_, **kwargs_)
        else:
            return abstract(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='abstract', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstract')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='abstract', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='abstract'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='abstract', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='abstract'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class abstract


class created(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if created.subclass:
            return created.subclass(*args_, **kwargs_)
        else:
            return created(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='created', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='created')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='created', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='created'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='created', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='created'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class created


class valid(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if valid.subclass:
            return valid.subclass(*args_, **kwargs_)
        else:
            return valid(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='valid', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='valid')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='valid', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='valid'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='valid', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='valid'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class valid


class available(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if available.subclass:
            return available.subclass(*args_, **kwargs_)
        else:
            return available(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='available', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='available')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='available', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='available'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='available', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='available'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class available


class issued(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if issued.subclass:
            return issued.subclass(*args_, **kwargs_)
        else:
            return issued(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='issued', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='issued')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='issued', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='issued'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='issued', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='issued'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class issued


class modified(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if modified.subclass:
            return modified.subclass(*args_, **kwargs_)
        else:
            return modified(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='modified', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='modified')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='modified', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='modified'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='modified', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='modified'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class modified


class dateAccepted(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if dateAccepted.subclass:
            return dateAccepted.subclass(*args_, **kwargs_)
        else:
            return dateAccepted(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='dateAccepted', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dateAccepted')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='dateAccepted', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='dateAccepted'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='dateAccepted', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='dateAccepted'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dateAccepted


class dateCopyrighted(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if dateCopyrighted.subclass:
            return dateCopyrighted.subclass(*args_, **kwargs_)
        else:
            return dateCopyrighted(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='dateCopyrighted', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dateCopyrighted')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='dateCopyrighted', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='dateCopyrighted'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='dateCopyrighted', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='dateCopyrighted'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dateCopyrighted


class dateSubmitted(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if dateSubmitted.subclass:
            return dateSubmitted.subclass(*args_, **kwargs_)
        else:
            return dateSubmitted(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='dateSubmitted', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dateSubmitted')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='dateSubmitted', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='dateSubmitted'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='dateSubmitted', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='dateSubmitted'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dateSubmitted


class extent(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if extent.subclass:
            return extent.subclass(*args_, **kwargs_)
        else:
            return extent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='extent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='extent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='extent', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='extent'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='extent', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='extent'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class extent


class medium(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if medium.subclass:
            return medium.subclass(*args_, **kwargs_)
        else:
            return medium(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='medium', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='medium')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='medium', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='medium'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='medium', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='medium'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class medium


class isVersionOf(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if isVersionOf.subclass:
            return isVersionOf.subclass(*args_, **kwargs_)
        else:
            return isVersionOf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='isVersionOf', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='isVersionOf')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='isVersionOf', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='isVersionOf'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='isVersionOf', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='isVersionOf'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class isVersionOf


class hasVersion(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if hasVersion.subclass:
            return hasVersion.subclass(*args_, **kwargs_)
        else:
            return hasVersion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='hasVersion', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='hasVersion')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='hasVersion', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='hasVersion'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='hasVersion', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='hasVersion'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class hasVersion


class isReplacedBy(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if isReplacedBy.subclass:
            return isReplacedBy.subclass(*args_, **kwargs_)
        else:
            return isReplacedBy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='isReplacedBy', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='isReplacedBy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='isReplacedBy', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='isReplacedBy'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='isReplacedBy', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='isReplacedBy'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class isReplacedBy


class replaces(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if replaces.subclass:
            return replaces.subclass(*args_, **kwargs_)
        else:
            return replaces(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='replaces', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='replaces')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='replaces', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='replaces'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='replaces', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='replaces'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class replaces


class isRequiredBy(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if isRequiredBy.subclass:
            return isRequiredBy.subclass(*args_, **kwargs_)
        else:
            return isRequiredBy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='isRequiredBy', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='isRequiredBy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='isRequiredBy', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='isRequiredBy'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='isRequiredBy', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='isRequiredBy'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class isRequiredBy


class requires(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if requires.subclass:
            return requires.subclass(*args_, **kwargs_)
        else:
            return requires(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='requires', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='requires')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='requires', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='requires'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='requires', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='requires'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class requires


class isPartOf(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if isPartOf.subclass:
            return isPartOf.subclass(*args_, **kwargs_)
        else:
            return isPartOf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='isPartOf', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='isPartOf')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='isPartOf', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='isPartOf'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='isPartOf', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='isPartOf'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class isPartOf


class hasPart(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if hasPart.subclass:
            return hasPart.subclass(*args_, **kwargs_)
        else:
            return hasPart(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='hasPart', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='hasPart')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='hasPart', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='hasPart'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='hasPart', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='hasPart'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class hasPart


class isReferencedBy(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if isReferencedBy.subclass:
            return isReferencedBy.subclass(*args_, **kwargs_)
        else:
            return isReferencedBy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='isReferencedBy', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='isReferencedBy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='isReferencedBy', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='isReferencedBy'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='isReferencedBy', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='isReferencedBy'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class isReferencedBy


class references(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if references.subclass:
            return references.subclass(*args_, **kwargs_)
        else:
            return references(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='references', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='references')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='references', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='references'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='references', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='references'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class references


class isFormatOf(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if isFormatOf.subclass:
            return isFormatOf.subclass(*args_, **kwargs_)
        else:
            return isFormatOf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='isFormatOf', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='isFormatOf')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='isFormatOf', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='isFormatOf'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='isFormatOf', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='isFormatOf'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class isFormatOf


class hasFormat(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if hasFormat.subclass:
            return hasFormat.subclass(*args_, **kwargs_)
        else:
            return hasFormat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='hasFormat', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='hasFormat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='hasFormat', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='hasFormat'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='hasFormat', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='hasFormat'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class hasFormat


class conformsTo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if conformsTo.subclass:
            return conformsTo.subclass(*args_, **kwargs_)
        else:
            return conformsTo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='conformsTo', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='conformsTo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='conformsTo', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='conformsTo'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='conformsTo', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='conformsTo'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class conformsTo


class spatial(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if spatial.subclass:
            return spatial.subclass(*args_, **kwargs_)
        else:
            return spatial(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='spatial', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='spatial')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='spatial', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='spatial'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='spatial', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='spatial'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class spatial


class temporal(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if temporal.subclass:
            return temporal.subclass(*args_, **kwargs_)
        else:
            return temporal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='temporal', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='temporal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='temporal', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='temporal'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='temporal', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='temporal'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class temporal


class audience(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if audience.subclass:
            return audience.subclass(*args_, **kwargs_)
        else:
            return audience(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='audience', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='audience')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='audience', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='audience'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='audience', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='audience'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class audience


class accrualMethod(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if accrualMethod.subclass:
            return accrualMethod.subclass(*args_, **kwargs_)
        else:
            return accrualMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='accrualMethod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accrualMethod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='accrualMethod', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='accrualMethod'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='accrualMethod', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='accrualMethod'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class accrualMethod


class accrualPeriodicity(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if accrualPeriodicity.subclass:
            return accrualPeriodicity.subclass(*args_, **kwargs_)
        else:
            return accrualPeriodicity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='accrualPeriodicity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accrualPeriodicity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='accrualPeriodicity', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='accrualPeriodicity'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='accrualPeriodicity', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='accrualPeriodicity'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class accrualPeriodicity


class accrualPolicy(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if accrualPolicy.subclass:
            return accrualPolicy.subclass(*args_, **kwargs_)
        else:
            return accrualPolicy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='accrualPolicy', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accrualPolicy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='accrualPolicy', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='accrualPolicy'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='accrualPolicy', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='accrualPolicy'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class accrualPolicy


class instructionalMethod(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if instructionalMethod.subclass:
            return instructionalMethod.subclass(*args_, **kwargs_)
        else:
            return instructionalMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='instructionalMethod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='instructionalMethod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='instructionalMethod', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='instructionalMethod'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='instructionalMethod', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='instructionalMethod'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class instructionalMethod


class provenance(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if provenance.subclass:
            return provenance.subclass(*args_, **kwargs_)
        else:
            return provenance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='provenance', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='provenance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='provenance', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='provenance'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='provenance', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='provenance'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class provenance


class rightsHolder(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if rightsHolder.subclass:
            return rightsHolder.subclass(*args_, **kwargs_)
        else:
            return rightsHolder(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='rightsHolder', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rightsHolder')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='rightsHolder', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='rightsHolder'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='rightsHolder', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='rightsHolder'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class rightsHolder


class mediator(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if mediator.subclass:
            return mediator.subclass(*args_, **kwargs_)
        else:
            return mediator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='mediator', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mediator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='mediator', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='mediator'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='mediator', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='mediator'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class mediator


class educationLevel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if educationLevel.subclass:
            return educationLevel.subclass(*args_, **kwargs_)
        else:
            return educationLevel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='educationLevel', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='educationLevel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='educationLevel', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='educationLevel'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='educationLevel', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='educationLevel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class educationLevel


class accessRights(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if accessRights.subclass:
            return accessRights.subclass(*args_, **kwargs_)
        else:
            return accessRights(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='accessRights', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accessRights')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='accessRights', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='accessRights'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='accessRights', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='accessRights'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class accessRights


class license(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if license.subclass:
            return license.subclass(*args_, **kwargs_)
        else:
            return license(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='license', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='license')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='license', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='license'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='license', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='license'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class license


class bibliographicCitation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if bibliographicCitation.subclass:
            return bibliographicCitation.subclass(*args_, **kwargs_)
        else:
            return bibliographicCitation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='bibliographicCitation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='bibliographicCitation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='bibliographicCitation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='bibliographicCitation'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='bibliographicCitation', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='bibliographicCitation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class bibliographicCitation


class elementOrRefinementContainer(GeneratedsSuper):
    """This is included as a convenience for schema authors who need to
    define a root or container element for all of the DC elements
    and element refinements."""
    subclass = None
    superclass = None
    def __init__(self, any=None):
        self.original_tagname_ = None
        if any is None:
            self.any = []
        else:
            self.any = any
    def factory(*args_, **kwargs_):
        if elementOrRefinementContainer.subclass:
            return elementOrRefinementContainer.subclass(*args_, **kwargs_)
        else:
            return elementOrRefinementContainer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_any(self): return self.any
    def set_any(self, any): self.any = any
    def add_any(self, value): self.any.append(value)
    def insert_any_at(self, index, value): self.any.insert(index, value)
    def replace_any_at(self, index, value): self.any[index] = value
    def hasContent_(self):
        if (
            self.any
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='elementOrRefinementContainer', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='elementOrRefinementContainer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='elementOrRefinementContainer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='elementOrRefinementContainer'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='elementOrRefinementContainer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for any_ in self.any:
            any_.export(outfile, level, namespace_, name_='any', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='elementOrRefinementContainer'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('any=[\n')
        level += 1
        for any_ in self.any:
            showIndent(outfile, level)
            outfile.write('model_.any(\n')
            any_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'any':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <any> element')
            self.any.append(obj_)
            obj_.original_tagname_ = 'any'
        elif nodeName_ == 'audience':
            obj_ = audience.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'audience'
        elif nodeName_ == 'accrualMethod':
            obj_ = accrualMethod.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'accrualMethod'
        elif nodeName_ == 'accrualPeriodicity':
            obj_ = accrualPeriodicity.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'accrualPeriodicity'
        elif nodeName_ == 'accrualPolicy':
            obj_ = accrualPolicy.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'accrualPolicy'
        elif nodeName_ == 'instructionalMethod':
            obj_ = instructionalMethod.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'instructionalMethod'
        elif nodeName_ == 'provenance':
            obj_ = provenance.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'provenance'
        elif nodeName_ == 'rightsHolder':
            obj_ = rightsHolder.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'rightsHolder'
        elif nodeName_ == 'title':
            obj_ = title.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'creator':
            obj_ = creator.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'creator'
        elif nodeName_ == 'subject':
            obj_ = subject.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'publisher':
            obj_ = publisher.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'publisher'
        elif nodeName_ == 'contributor':
            obj_ = contributor.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'contributor'
        elif nodeName_ == 'date':
            obj_ = date.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'date'
        elif nodeName_ == 'type':
            obj_ = type_.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'format':
            obj_ = format.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'format'
        elif nodeName_ == 'identifier':
            obj_ = identifier.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'source':
            obj_ = source.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'source'
        elif nodeName_ == 'language':
            obj_ = language.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'language'
        elif nodeName_ == 'relation':
            obj_ = relation.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'relation'
        elif nodeName_ == 'coverage':
            obj_ = coverage.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'coverage'
        elif nodeName_ == 'rights':
            obj_ = rights.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'rights'
        elif nodeName_ == 'mediator':
            obj_ = mediator.factory()
            obj_.build(child_)
            self.audience.append(obj_)
            obj_.original_tagname_ = 'mediator'
        elif nodeName_ == 'educationLevel':
            obj_ = educationLevel.factory()
            obj_.build(child_)
            self.audience.append(obj_)
            obj_.original_tagname_ = 'educationLevel'
        elif nodeName_ == 'title':
            obj_ = title.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'alternative':
            obj_ = alternative.factory()
            obj_.build(child_)
            self.title.append(obj_)
            obj_.original_tagname_ = 'alternative'
        elif nodeName_ == 'creator':
            obj_ = creator.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'creator'
        elif nodeName_ == 'subject':
            obj_ = subject.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'tableOfContents':
            obj_ = tableOfContents.factory()
            obj_.build(child_)
            self.description.append(obj_)
            obj_.original_tagname_ = 'tableOfContents'
        elif nodeName_ == 'abstract':
            obj_ = abstract.factory()
            obj_.build(child_)
            self.description.append(obj_)
            obj_.original_tagname_ = 'abstract'
        elif nodeName_ == 'publisher':
            obj_ = publisher.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'publisher'
        elif nodeName_ == 'contributor':
            obj_ = contributor.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'contributor'
        elif nodeName_ == 'date':
            obj_ = date.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'date'
        elif nodeName_ == 'created':
            obj_ = created.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'created'
        elif nodeName_ == 'valid':
            obj_ = valid.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'valid'
        elif nodeName_ == 'available':
            obj_ = available.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'available'
        elif nodeName_ == 'issued':
            obj_ = issued.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'issued'
        elif nodeName_ == 'modified':
            obj_ = modified.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'modified'
        elif nodeName_ == 'dateAccepted':
            obj_ = dateAccepted.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'dateAccepted'
        elif nodeName_ == 'dateCopyrighted':
            obj_ = dateCopyrighted.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'dateCopyrighted'
        elif nodeName_ == 'dateSubmitted':
            obj_ = dateSubmitted.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'dateSubmitted'
        elif nodeName_ == 'type':
            obj_ = type_.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'format':
            obj_ = format.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'format'
        elif nodeName_ == 'extent':
            obj_ = extent.factory()
            obj_.build(child_)
            self.format.append(obj_)
            obj_.original_tagname_ = 'extent'
        elif nodeName_ == 'medium':
            obj_ = medium.factory()
            obj_.build(child_)
            self.format.append(obj_)
            obj_.original_tagname_ = 'medium'
        elif nodeName_ == 'identifier':
            obj_ = identifier.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'bibliographicCitation':
            obj_ = bibliographicCitation.factory()
            obj_.build(child_)
            self.identifier.append(obj_)
            obj_.original_tagname_ = 'bibliographicCitation'
        elif nodeName_ == 'source':
            obj_ = source.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'source'
        elif nodeName_ == 'language':
            obj_ = language.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'language'
        elif nodeName_ == 'relation':
            obj_ = relation.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'relation'
        elif nodeName_ == 'isVersionOf':
            obj_ = isVersionOf.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'isVersionOf'
        elif nodeName_ == 'hasVersion':
            obj_ = hasVersion.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'hasVersion'
        elif nodeName_ == 'isReplacedBy':
            obj_ = isReplacedBy.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'isReplacedBy'
        elif nodeName_ == 'replaces':
            obj_ = replaces.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'replaces'
        elif nodeName_ == 'isRequiredBy':
            obj_ = isRequiredBy.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'isRequiredBy'
        elif nodeName_ == 'requires':
            obj_ = requires.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'requires'
        elif nodeName_ == 'isPartOf':
            obj_ = isPartOf.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'isPartOf'
        elif nodeName_ == 'hasPart':
            obj_ = hasPart.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'hasPart'
        elif nodeName_ == 'isReferencedBy':
            obj_ = isReferencedBy.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'isReferencedBy'
        elif nodeName_ == 'references':
            obj_ = references.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'references'
        elif nodeName_ == 'isFormatOf':
            obj_ = isFormatOf.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'isFormatOf'
        elif nodeName_ == 'hasFormat':
            obj_ = hasFormat.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'hasFormat'
        elif nodeName_ == 'conformsTo':
            obj_ = conformsTo.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'conformsTo'
        elif nodeName_ == 'coverage':
            obj_ = coverage.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'coverage'
        elif nodeName_ == 'spatial':
            obj_ = spatial.factory()
            obj_.build(child_)
            self.coverage.append(obj_)
            obj_.original_tagname_ = 'spatial'
        elif nodeName_ == 'temporal':
            obj_ = temporal.factory()
            obj_.build(child_)
            self.coverage.append(obj_)
            obj_.original_tagname_ = 'temporal'
        elif nodeName_ == 'rights':
            obj_ = rights.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'rights'
        elif nodeName_ == 'accessRights':
            obj_ = accessRights.factory()
            obj_.build(child_)
            self.rights.append(obj_)
            obj_.original_tagname_ = 'accessRights'
        elif nodeName_ == 'license':
            obj_ = license.factory()
            obj_.build(child_)
            self.rights.append(obj_)
            obj_.original_tagname_ = 'license'
# end class elementOrRefinementContainer


class SimpleLiteral(GeneratedsSuper):
    """This is the default type for all of the DC elements. It permits text
    content only with optional xml:lang attribute. Text is allowed
    because mixed="true", but sub-elements are disallowed because
    minOccurs="0" and maxOccurs="0" are on the xs:any tag. This
    complexType allows for restriction or extension permitting child
    elements."""
    subclass = None
    superclass = None
    def __init__(self, lang=None, anytypeobjs_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.lang = _cast(None, lang)
        self.anytypeobjs_ = anytypeobjs_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if SimpleLiteral.subclass:
            return SimpleLiteral.subclass(*args_, **kwargs_)
        else:
            return SimpleLiteral(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='SimpleLiteral', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleLiteral')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='SimpleLiteral', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='SimpleLiteral'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='cs:', name_='SimpleLiteral', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SimpleLiteral'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'SimpleLiteral')
        if obj_ is not None:
            self.set_anytypeobjs_(obj_)
# end class SimpleLiteral


class elementContainer(GeneratedsSuper):
    """This complexType is included as a convenience for schema authors who
    need to define a root or container element for all of the DC
    elements."""
    subclass = None
    superclass = None
    def __init__(self, any=None):
        self.original_tagname_ = None
        if any is None:
            self.any = []
        else:
            self.any = any
    def factory(*args_, **kwargs_):
        if elementContainer.subclass:
            return elementContainer.subclass(*args_, **kwargs_)
        else:
            return elementContainer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_any(self): return self.any
    def set_any(self, any): self.any = any
    def add_any(self, value): self.any.append(value)
    def insert_any_at(self, index, value): self.any.insert(index, value)
    def replace_any_at(self, index, value): self.any[index] = value
    def hasContent_(self):
        if (
            self.any
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='elementContainer', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='elementContainer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='elementContainer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='elementContainer'):
        pass
    def exportChildren(self, outfile, level, namespace_='cs:', name_='elementContainer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for any_ in self.any:
            any_.export(outfile, level, namespace_, name_='any', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='elementContainer'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('any=[\n')
        level += 1
        for any_ in self.any:
            showIndent(outfile, level)
            outfile.write('model_.any(\n')
            any_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'any':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <any> element')
            self.any.append(obj_)
            obj_.original_tagname_ = 'any'
        elif nodeName_ == 'audience':
            obj_ = audience.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'audience'
        elif nodeName_ == 'accrualMethod':
            obj_ = accrualMethod.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'accrualMethod'
        elif nodeName_ == 'accrualPeriodicity':
            obj_ = accrualPeriodicity.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'accrualPeriodicity'
        elif nodeName_ == 'accrualPolicy':
            obj_ = accrualPolicy.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'accrualPolicy'
        elif nodeName_ == 'instructionalMethod':
            obj_ = instructionalMethod.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'instructionalMethod'
        elif nodeName_ == 'provenance':
            obj_ = provenance.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'provenance'
        elif nodeName_ == 'rightsHolder':
            obj_ = rightsHolder.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'rightsHolder'
        elif nodeName_ == 'title':
            obj_ = title.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'creator':
            obj_ = creator.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'creator'
        elif nodeName_ == 'subject':
            obj_ = subject.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'publisher':
            obj_ = publisher.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'publisher'
        elif nodeName_ == 'contributor':
            obj_ = contributor.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'contributor'
        elif nodeName_ == 'date':
            obj_ = date.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'date'
        elif nodeName_ == 'type':
            obj_ = type_.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'format':
            obj_ = format.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'format'
        elif nodeName_ == 'identifier':
            obj_ = identifier.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'source':
            obj_ = source.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'source'
        elif nodeName_ == 'language':
            obj_ = language.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'language'
        elif nodeName_ == 'relation':
            obj_ = relation.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'relation'
        elif nodeName_ == 'coverage':
            obj_ = coverage.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'coverage'
        elif nodeName_ == 'rights':
            obj_ = rights.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'rights'
        elif nodeName_ == 'mediator':
            obj_ = mediator.factory()
            obj_.build(child_)
            self.audience.append(obj_)
            obj_.original_tagname_ = 'mediator'
        elif nodeName_ == 'educationLevel':
            obj_ = educationLevel.factory()
            obj_.build(child_)
            self.audience.append(obj_)
            obj_.original_tagname_ = 'educationLevel'
        elif nodeName_ == 'title':
            obj_ = title.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'alternative':
            obj_ = alternative.factory()
            obj_.build(child_)
            self.title.append(obj_)
            obj_.original_tagname_ = 'alternative'
        elif nodeName_ == 'creator':
            obj_ = creator.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'creator'
        elif nodeName_ == 'subject':
            obj_ = subject.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'tableOfContents':
            obj_ = tableOfContents.factory()
            obj_.build(child_)
            self.description.append(obj_)
            obj_.original_tagname_ = 'tableOfContents'
        elif nodeName_ == 'abstract':
            obj_ = abstract.factory()
            obj_.build(child_)
            self.description.append(obj_)
            obj_.original_tagname_ = 'abstract'
        elif nodeName_ == 'publisher':
            obj_ = publisher.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'publisher'
        elif nodeName_ == 'contributor':
            obj_ = contributor.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'contributor'
        elif nodeName_ == 'date':
            obj_ = date.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'date'
        elif nodeName_ == 'created':
            obj_ = created.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'created'
        elif nodeName_ == 'valid':
            obj_ = valid.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'valid'
        elif nodeName_ == 'available':
            obj_ = available.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'available'
        elif nodeName_ == 'issued':
            obj_ = issued.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'issued'
        elif nodeName_ == 'modified':
            obj_ = modified.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'modified'
        elif nodeName_ == 'dateAccepted':
            obj_ = dateAccepted.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'dateAccepted'
        elif nodeName_ == 'dateCopyrighted':
            obj_ = dateCopyrighted.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'dateCopyrighted'
        elif nodeName_ == 'dateSubmitted':
            obj_ = dateSubmitted.factory()
            obj_.build(child_)
            self.date.append(obj_)
            obj_.original_tagname_ = 'dateSubmitted'
        elif nodeName_ == 'type':
            obj_ = type_.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'format':
            obj_ = format.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'format'
        elif nodeName_ == 'extent':
            obj_ = extent.factory()
            obj_.build(child_)
            self.format.append(obj_)
            obj_.original_tagname_ = 'extent'
        elif nodeName_ == 'medium':
            obj_ = medium.factory()
            obj_.build(child_)
            self.format.append(obj_)
            obj_.original_tagname_ = 'medium'
        elif nodeName_ == 'identifier':
            obj_ = identifier.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'bibliographicCitation':
            obj_ = bibliographicCitation.factory()
            obj_.build(child_)
            self.identifier.append(obj_)
            obj_.original_tagname_ = 'bibliographicCitation'
        elif nodeName_ == 'source':
            obj_ = source.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'source'
        elif nodeName_ == 'language':
            obj_ = language.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'language'
        elif nodeName_ == 'relation':
            obj_ = relation.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'relation'
        elif nodeName_ == 'isVersionOf':
            obj_ = isVersionOf.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'isVersionOf'
        elif nodeName_ == 'hasVersion':
            obj_ = hasVersion.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'hasVersion'
        elif nodeName_ == 'isReplacedBy':
            obj_ = isReplacedBy.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'isReplacedBy'
        elif nodeName_ == 'replaces':
            obj_ = replaces.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'replaces'
        elif nodeName_ == 'isRequiredBy':
            obj_ = isRequiredBy.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'isRequiredBy'
        elif nodeName_ == 'requires':
            obj_ = requires.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'requires'
        elif nodeName_ == 'isPartOf':
            obj_ = isPartOf.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'isPartOf'
        elif nodeName_ == 'hasPart':
            obj_ = hasPart.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'hasPart'
        elif nodeName_ == 'isReferencedBy':
            obj_ = isReferencedBy.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'isReferencedBy'
        elif nodeName_ == 'references':
            obj_ = references.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'references'
        elif nodeName_ == 'isFormatOf':
            obj_ = isFormatOf.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'isFormatOf'
        elif nodeName_ == 'hasFormat':
            obj_ = hasFormat.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'hasFormat'
        elif nodeName_ == 'conformsTo':
            obj_ = conformsTo.factory()
            obj_.build(child_)
            self.relation.append(obj_)
            obj_.original_tagname_ = 'conformsTo'
        elif nodeName_ == 'coverage':
            obj_ = coverage.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'coverage'
        elif nodeName_ == 'spatial':
            obj_ = spatial.factory()
            obj_.build(child_)
            self.coverage.append(obj_)
            obj_.original_tagname_ = 'spatial'
        elif nodeName_ == 'temporal':
            obj_ = temporal.factory()
            obj_.build(child_)
            self.coverage.append(obj_)
            obj_.original_tagname_ = 'temporal'
        elif nodeName_ == 'rights':
            obj_ = rights.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'rights'
        elif nodeName_ == 'accessRights':
            obj_ = accessRights.factory()
            obj_.build(child_)
            self.rights.append(obj_)
            obj_.original_tagname_ = 'accessRights'
        elif nodeName_ == 'license':
            obj_ = license.factory()
            obj_.build(child_)
            self.rights.append(obj_)
            obj_.original_tagname_ = 'license'
# end class elementContainer


class TGN(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(TGN, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if TGN.subclass:
            return TGN.subclass(*args_, **kwargs_)
        else:
            return TGN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(TGN, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='TGN', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TGN')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='TGN', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='TGN'):
        super(TGN, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TGN')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='TGN', fromsubclass_=False, pretty_print=True):
        super(TGN, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TGN'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(TGN, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TGN, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(TGN, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TGN


class Box(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(Box, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Box.subclass:
            return Box.subclass(*args_, **kwargs_)
        else:
            return Box(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(Box, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='Box', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Box')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='Box', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='Box'):
        super(Box, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Box')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='Box', fromsubclass_=False, pretty_print=True):
        super(Box, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Box'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(Box, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Box, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(Box, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Box


class ISO3166(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(ISO3166, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ISO3166.subclass:
            return ISO3166.subclass(*args_, **kwargs_)
        else:
            return ISO3166(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(ISO3166, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='ISO3166', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ISO3166')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='ISO3166', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='ISO3166'):
        super(ISO3166, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ISO3166')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='ISO3166', fromsubclass_=False, pretty_print=True):
        super(ISO3166, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ISO3166'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(ISO3166, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ISO3166, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(ISO3166, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ISO3166


class Point(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(Point, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Point.subclass:
            return Point.subclass(*args_, **kwargs_)
        else:
            return Point(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(Point, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='Point', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Point')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='Point', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='Point'):
        super(Point, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Point')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='Point', fromsubclass_=False, pretty_print=True):
        super(Point, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Point'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(Point, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Point, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(Point, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Point


class RFC4646(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(RFC4646, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if RFC4646.subclass:
            return RFC4646.subclass(*args_, **kwargs_)
        else:
            return RFC4646(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(RFC4646, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='RFC4646', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RFC4646')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='RFC4646', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='RFC4646'):
        super(RFC4646, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RFC4646')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='RFC4646', fromsubclass_=False, pretty_print=True):
        super(RFC4646, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RFC4646'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(RFC4646, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RFC4646, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(RFC4646, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RFC4646


class RFC3066(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(RFC3066, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if RFC3066.subclass:
            return RFC3066.subclass(*args_, **kwargs_)
        else:
            return RFC3066(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(RFC3066, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='RFC3066', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RFC3066')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='RFC3066', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='RFC3066'):
        super(RFC3066, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RFC3066')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='RFC3066', fromsubclass_=False, pretty_print=True):
        super(RFC3066, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RFC3066'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(RFC3066, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RFC3066, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(RFC3066, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RFC3066


class RFC1766(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(RFC1766, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if RFC1766.subclass:
            return RFC1766.subclass(*args_, **kwargs_)
        else:
            return RFC1766(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(RFC1766, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='RFC1766', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RFC1766')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='RFC1766', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='RFC1766'):
        super(RFC1766, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RFC1766')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='RFC1766', fromsubclass_=False, pretty_print=True):
        super(RFC1766, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RFC1766'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(RFC1766, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RFC1766, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(RFC1766, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RFC1766


class ISO639_3(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(ISO639_3, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ISO639_3.subclass:
            return ISO639_3.subclass(*args_, **kwargs_)
        else:
            return ISO639_3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(ISO639_3, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='ISO639-3', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ISO639-3')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='ISO639-3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='ISO639-3'):
        super(ISO639_3, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ISO639-3')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='ISO639-3', fromsubclass_=False, pretty_print=True):
        super(ISO639_3, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ISO639-3'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(ISO639_3, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ISO639_3, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(ISO639_3, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ISO639_3


class ISO639_2(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(ISO639_2, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ISO639_2.subclass:
            return ISO639_2.subclass(*args_, **kwargs_)
        else:
            return ISO639_2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(ISO639_2, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='ISO639-2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ISO639-2')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='ISO639-2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='ISO639-2'):
        super(ISO639_2, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ISO639-2')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='ISO639-2', fromsubclass_=False, pretty_print=True):
        super(ISO639_2, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ISO639-2'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(ISO639_2, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ISO639_2, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(ISO639_2, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ISO639_2


class URI(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(URI, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if URI.subclass:
            return URI.subclass(*args_, **kwargs_)
        else:
            return URI(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(URI, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='URI', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='URI')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='URI', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='URI'):
        super(URI, self).exportAttributes(outfile, level, already_processed, namespace_, name_='URI')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='URI', fromsubclass_=False, pretty_print=True):
        super(URI, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='URI'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(URI, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(URI, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(URI, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class URI


class IMT(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(IMT, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if IMT.subclass:
            return IMT.subclass(*args_, **kwargs_)
        else:
            return IMT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(IMT, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='IMT', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IMT')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='IMT', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='IMT'):
        super(IMT, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IMT')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='IMT', fromsubclass_=False, pretty_print=True):
        super(IMT, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IMT'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(IMT, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IMT, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(IMT, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IMT


class DCMIType(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(DCMIType, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DCMIType.subclass:
            return DCMIType.subclass(*args_, **kwargs_)
        else:
            return DCMIType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(DCMIType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='DCMIType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DCMIType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='DCMIType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='DCMIType'):
        super(DCMIType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DCMIType')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='DCMIType', fromsubclass_=False, pretty_print=True):
        super(DCMIType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DCMIType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(DCMIType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DCMIType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(DCMIType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DCMIType


class W3CDTF(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(W3CDTF, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if W3CDTF.subclass:
            return W3CDTF.subclass(*args_, **kwargs_)
        else:
            return W3CDTF(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(W3CDTF, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='W3CDTF', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='W3CDTF')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='W3CDTF', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='W3CDTF'):
        super(W3CDTF, self).exportAttributes(outfile, level, already_processed, namespace_, name_='W3CDTF')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='W3CDTF', fromsubclass_=False, pretty_print=True):
        super(W3CDTF, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='W3CDTF'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(W3CDTF, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(W3CDTF, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(W3CDTF, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class W3CDTF


class Period(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(Period, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Period.subclass:
            return Period.subclass(*args_, **kwargs_)
        else:
            return Period(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(Period, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='Period', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Period')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='Period', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='Period'):
        super(Period, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Period')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='Period', fromsubclass_=False, pretty_print=True):
        super(Period, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Period'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(Period, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Period, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(Period, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Period


class UDC(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(UDC, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if UDC.subclass:
            return UDC.subclass(*args_, **kwargs_)
        else:
            return UDC(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(UDC, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='UDC', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UDC')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='UDC', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='UDC'):
        super(UDC, self).exportAttributes(outfile, level, already_processed, namespace_, name_='UDC')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='UDC', fromsubclass_=False, pretty_print=True):
        super(UDC, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='UDC'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(UDC, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(UDC, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(UDC, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class UDC


class LCC(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(LCC, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if LCC.subclass:
            return LCC.subclass(*args_, **kwargs_)
        else:
            return LCC(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(LCC, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='LCC', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LCC')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='LCC', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='LCC'):
        super(LCC, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LCC')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='LCC', fromsubclass_=False, pretty_print=True):
        super(LCC, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LCC'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(LCC, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LCC, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(LCC, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LCC


class DDC(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(DDC, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DDC.subclass:
            return DDC.subclass(*args_, **kwargs_)
        else:
            return DDC(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(DDC, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='DDC', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DDC')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='DDC', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='DDC'):
        super(DDC, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DDC')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='DDC', fromsubclass_=False, pretty_print=True):
        super(DDC, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DDC'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(DDC, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DDC, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(DDC, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DDC


class MESH(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(MESH, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if MESH.subclass:
            return MESH.subclass(*args_, **kwargs_)
        else:
            return MESH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(MESH, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='MESH', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MESH')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='MESH', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='MESH'):
        super(MESH, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MESH')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='MESH', fromsubclass_=False, pretty_print=True):
        super(MESH, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MESH'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(MESH, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MESH, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(MESH, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MESH


class LCSH(SimpleLiteral):
    subclass = None
    superclass = SimpleLiteral
    def __init__(self, lang=None, anytypeobjs_=None, valueOf_=None):
        self.original_tagname_ = None
        super(LCSH, self).__init__(lang, anytypeobjs_, valueOf_, )
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if LCSH.subclass:
            return LCSH.subclass(*args_, **kwargs_)
        else:
            return LCSH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(LCSH, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cs:', name_='LCSH', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LCSH')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cs:', name_='LCSH', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cs:', name_='LCSH'):
        super(LCSH, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LCSH')
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cs:', name_='LCSH', fromsubclass_=False, pretty_print=True):
        super(LCSH, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LCSH'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        super(LCSH, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LCSH, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        super(LCSH, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LCSH


GDSClassesMapping = {
    'normalModeSymmetry': stringArrayType,
    'normalModes': normalModesType,
    'sourcePackage': sourcePackageType,
    'caspt2': resultType,
    'ramanIntensities': stringArrayType,
    'semiEmpiricalScf': resultType,
    'scf': resultType,
    'orbitalEnergies': stringArrayType,
    'multipleDeterminant': mrsmdMethodType,
    'irIntensities': stringArrayType,
    'betaOrbitals': orbitalsType,
    'mp4': resultType,
    'mp2': resultType,
    'mp3': resultType,
    'multipleReferenceState': mrsMethodType,
    'coordination': coordinationType,
    'moleculeProperty': propertyType,
    'residue': residueType,
    'vibrationalAnalysis': vibAnalysisType,
    'ccd': resultType,
    'group': groupType,
    'author': authorType,
    'energies': energiesType,
    'dft': resultType,
    'molecularSystem': msType,
    'normalMode': normalModeType,
    'any': SimpleLiteral,
    'xCoord3D': dataWithUnitsType,
    'orbital': stringArrayType,
    'residueProperty': propertyType,
    'abinitioScf': resultType,
    'alphaOrbitals': orbitalsType,
    'molecularCalculation': mcType,
    'chemicalSemantics': csType,
    'multiscale': msCalcType,
    'alphaOrbitalEnergies': stringArrayType,
    'singleDeterminant': srssdMethodType,
    'energy': energyType,
    'frequencies': stringArrayType,
    'systemProperty': propertyType,
    'waveFunction': waveFunctionType,
    'molecule': moleculeType,
    'orbitals': orbitalsType,
    'electronicSpectra': elecSpectraType,
    'molecularMechanics': mmCalcType,
    'atom': atomType,
    'mcscf': resultType,
    'zCoord3D': dataWithUnitsType,
    'properties': propertiesType,
    'condition': conditionType,
    'atomProperty': propertyType,
    'betaOrbitalEnergies': stringArrayType,
    'oscillatorStrength': stringArrayType,
    'quantumMechanics': qmCalcType,
    'ccsd': resultType,
    'molecularPublication': mpType,
    'statisticalMechanics': smCalcType,
    'electronicTransitions': stringArrayType,
    'cis': resultType,
    'singleReferenceState': srsMethodType,
    'groupProperty': propertyType,
    'ccsd-t': resultType,
    'cisd': resultType,
    'systemTemperature': dataWithUnitsType,
    'bond': bondType,
    'yCoord3D': dataWithUnitsType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'csType'
        rootClass = csType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:cs=http://chemicalsemantics.com/csx xmlns:dcterms=http:/purl.org/dc/terms/',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'csType'
        rootClass = csType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'csType'
        rootClass = csType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:cs=http://chemicalsemantics.com/csx xmlns:dcterms=http:/purl.org/dc/terms/')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'csType'
        rootClass = csType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from csx1_api import *\n\n')
        sys.stdout.write('import csx1_api as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()

def chemElement():

    elm_symbol = ["X", "H", "He", "Li", "Be", "B", "C", "N", "O", "F", "Ne", "Na", "Mg",
        "Al", "Si", "P", "S", "Cl", "Ar", "K", "Ca", "Sc", "Ti", "V", "Cr", "Mn", "Fe", "Co",
        "Ni", "Cu", "Zn", "Ga", "Ge", "As", "Se", "Br", "Kr", "Rb", "Sr", "Y", "Zr", "Nb",
        "Mo", "Tc", "Ru", "Rh", "Pd", "Ag", "Cd", "In", "Sn", "Sb", "Te", "I", "Xe", "Cs",
        "Ba", "La", "Ce", "Pr", "Nd", "Pm", "Sm", "Eu", "Gd", "Tb", "Dy", "Ho", "Er", "Tm",
        "Yb", "Lu", "Hf", "Ta", "W", "Re", "Os", "Ir", "Pt", "Au", "Hg", "Tl", "Pb", "Bi",
        "Po", "At", "Rn", "Fr", "Ra", "Ac", "Th", "Pa", "U", "Np", "Pu", "Am", "Cm", "Bk",
        "Cf", "Es", "Fm", "Md", "No", "Lr", "Rf", "Db", "Sg", "Bh", "Hs", "Mt", "Ds", "Rg",
        "Cn", "Uut", "Fl", "Uup", "Lv", "Uus", "Uuo"]

    elm_z = list(range(0, 118))
    elm2z = dict(zip(elm_symbol, elm_z))
    z2elm = dict(zip(elm_z, elm_symbol))

if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "Box",
    "DCMIType",
    "DDC",
    "IMT",
    "ISO3166",
    "ISO639_2",
    "ISO639_3",
    "LCC",
    "LCSH",
    "MESH",
    "Period",
    "Point",
    "RFC1766",
    "RFC3066",
    "RFC4646",
    "SimpleLiteral",
    "TGN",
    "UDC",
    "URI",
    "W3CDTF",
    "abstract",
    "accessRights",
    "accrualMethod",
    "accrualPeriodicity",
    "accrualPolicy",
    "alternative",
    "atomType",
    "audience",
    "authorType",
    "available",
    "bibliographicCitation",
    "bondType",
    "conditionType",
    "conformsTo",
    "contributor",
    "coordinationType",
    "coverage",
    "created",
    "creator",
    "csType",
    "dataWithUnitsType",
    "date",
    "dateAccepted",
    "dateCopyrighted",
    "dateSubmitted",
    "description",
    "educationLevel",
    "elecSpectraType",
    "elementContainer",
    "elementOrRefinementContainer",
    "energiesType",
    "energyType",
    "extent",
    "format",
    "groupType",
    "hasFormat",
    "hasPart",
    "hasVersion",
    "identifier",
    "instructionalMethod",
    "isFormatOf",
    "isPartOf",
    "isReferencedBy",
    "isReplacedBy",
    "isRequiredBy",
    "isVersionOf",
    "issued",
    "language",
    "license",
    "mcType",
    "mediator",
    "medium",
    "mmCalcType",
    "modified",
    "moleculeType",
    "mpType",
    "mrsMethodType",
    "mrsmdMethodType",
    "msCalcType",
    "msType",
    "normalModeType",
    "normalModesType",
    "orbitalsType",
    "propertiesType",
    "propertyType",
    "provenance",
    "publisher",
    "qmCalcType",
    "references",
    "relation",
    "replaces",
    "requires",
    "residueType",
    "resultType",
    "rights",
    "rightsHolder",
    "smCalcType",
    "source",
    "sourcePackageType",
    "spatial",
    "srsMethodType",
    "srsmdMethodType",
    "srssdMethodType",
    "stringArrayType",
    "subject",
    "tableOfContents",
    "temporal",
    "title",
    "type_",
    "valid",
    "vibAnalysisType",
    "waveFunctionType"
]
