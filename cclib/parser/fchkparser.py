# Copyright (c) 2025, the cclib development team
#
# This file is part of cclib (http://cclib.github.io) and is distributed under
# the terms of the BSD 3-Clause License.

"""Parser for Formatted Checkpoint files"""

from typing import TYPE_CHECKING, List, Optional, Type, TypeVar

from cclib.parser import data, logfileparser, utils
from cclib.parser.gaussianparser import parse_version as gaussian_parse_version

import numpy

if TYPE_CHECKING:
    from cclib.parser.logfilewrapper import FileWrapper

SHELL_ORBITALS = {
    0: ["S"],
    1: ["PX", "PY", "PZ"],
    -1: ["S", "PX", "PY", "PZ"],
    2: ["D1", "D2", "D3", "D4", "D5", "D6"],
    -2: ["D1", "D2", "D3", "D4", "D5"],
    3: ["F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10"],
    -3: ["F1", "F2", "F3", "F4", "F5", "F6", "F7"],
    4: ["G1", "G2", "G3", "G4", "G5", "G6", "G7", "G8", "G9", "G10", "G11", "G12", "G13"],
    -4: ["G1", "G2", "G3", "G4", "G5", "G6", "G7", "G8", "G9"],
}

SHELL_START = {0: 1, 1: 2, -1: 2, 2: 3, -2: 3, 3: 4, -3: 4}

T = TypeVar("T")


def _shell_to_orbitals(type: int, offset: int) -> List[str]:
    """Convert a Fchk shell type and offset to a list of string representations.

    For example, shell type = -2 corresponds to d orbitals (spherical basis) with
    an offset = 1 would correspond to the 4d orbitals, so this function returns
    `['4D1', '4D2', '4D3', '4D4', '4D5']`.
    """

    return [f"{SHELL_START[type] + offset}{x}" for x in SHELL_ORBITALS[type]]


class FChk(logfileparser.Logfile):
    """A Formatted checkpoint file, which contains molecular and wavefunction information.

    These files are produced by Gaussian and Q-Chem.
    """

    def __init__(self, *args, **kwargs):
        super().__init__(logname="FChk", *args, **kwargs)
        self.start = True

    def __str__(self) -> str:
        """Return a string representation of the object."""
        return f"Formatted checkpoint file {self.filename}"

    def __repr__(self) -> str:
        """Return a representation of the object."""
        return f'FCHK("{self.filename}")'

    def normalisesym(self, symlabel: str) -> str:
        """Just return label"""
        return symlabel

    def before_parsing(self) -> None:
        self.success = None

        # Used to differentiate between success and failure for Gaussian 03.
        self.gaussian_has_qeq_coupling_tensors = False

        self.gaussian_03_or_earlier = False

    def extract(self, inputfile: "FileWrapper", line: str) -> None:
        # just opened file
        if self.start:
            jobname = line.strip()
            if jobname == "Generated by Psi4":
                self.program = "Psi4"
            elif jobname == "Jobname.Temp":
                self.program = "QChem"
            details = next(inputfile).split()
            jobtype, *methods, basis = details
            self.metadata.update({"methods": methods, "basis_set": basis})
            self.jobtype = jobtype.lower()
            line = next(inputfile)
            assert line.startswith("Number of atoms")
            self.set_attribute("natom", int(line.split()[-1]))
            self.start = False

        if line[0:7] == "Info1-9":
            self.program = "Gaussian"

        if line[0:5] == "Route":
            assert self.program == "Gaussian"
            keyword_lines = []
            line = next(inputfile)
            while not line.startswith("Charge"):
                keyword_lines.append(line)
                line = next(inputfile)
            if "keywords" not in self.metadata:
                self.metadata["keywords"] = []
            self.metadata["keywords"].append("".join(line.strip() for line in keyword_lines))

        if line[0:6] == "Charge":
            self.set_attribute("charge", int(line.split()[-1]))

        if line[0:12] == "Multiplicity":
            self.set_attribute("mult", int(line.split()[-1]))

        if line[0:14] == "Atomic numbers":
            self.set_attribute("natom", int(line.split()[-1]))
            atomnos = self._parse_block(inputfile, self.natom, int, "Basic Information")
            self.set_attribute("atomnos", atomnos)

        if line[0:19] == "Number of electrons":
            alpha = next(inputfile)
            alpha_homo = int(alpha.split()[-1]) - 1

            beta = next(inputfile)
            beta_homo = int(beta.split()[-1]) - 1

            self.set_attribute("homos", [alpha_homo, beta_homo])

        if line[0:29] == "Current cartesian coordinates":
            count = int(line.split()[-1])
            assert count % 3 == 0

            coords = numpy.array(self._parse_block(inputfile, count, float, "Coordinates"))
            coords.shape = (int(count / 3), 3)
            self.append_attribute("atomcoords", utils.convertor(coords, "bohr", "Angstrom"))

        if line[0:10] == "SCF Energy":
            self.append_attribute("scfenergies", float(line.split()[-1]))

        if line[0:9] == "RMS Force":
            assert self.program == "Gaussian"
            # The maximum force, maximum displacement, and RMS displacement
            # are not printed, but add them for consistency.
            self.append_attribute(
                "geovalues", [numpy.nan, float(line.split()[-1]), numpy.nan, numpy.nan]
            )

        if line[0:11] == "RMS Density":
            assert self.program == "Gaussian"
            # The maximum change in the density matrix is not printed, but add
            # it for consistency.  Don't add the optional change in energy.
            self.append_attribute("scfvalues", [float(line.split()[-1]), numpy.nan])

        if line[0:25] == "Number of basis functions":
            self.set_attribute("nbasis", int(line.split()[-1]))

        if line[0:14] == "Overlap Matrix":
            count = int(line.split()[-1])
            self.set_attribute(
                "aooverlaps",
                utils.block_to_matrix(
                    numpy.asarray(self._parse_block(inputfile, count, float, "Overlap Matrix"))
                ),
            )

        # At least Gaussian 03 has this typo.
        if (
            line[0:31] == "Number of independent functions"
            or line[0:31] == "Number of independant functions"
        ):
            self.set_attribute("nmo", int(line.split()[-1]))
            if "independant" in line:
                self.gaussian_03_or_earlier = True

        if line[0:10] == "Job Status":
            job_status = int(line.split()[-1])
            self.success = job_status == 1

        if line[0:21] == "Alpha MO coefficients":
            count = int(line.split()[-1])
            assert count == self.nbasis * self.nmo

            coeffs = numpy.array(self._parse_block(inputfile, count, float, "Alpha Coefficients"))
            coeffs.shape = (self.nmo, self.nbasis)
            self.set_attribute("mocoeffs", [coeffs])

        if line[0:22] == "Alpha Orbital Energies":
            count = int(line.split()[-1])
            assert count == self.nmo

            energies = numpy.array(self._parse_block(inputfile, count, float, "Alpha MO Energies"))
            self.set_attribute("moenergies", [energies])

        if line[0:20] == "Beta MO coefficients":
            count = int(line.split()[-1])
            assert count == self.nbasis * self.nmo

            coeffs = numpy.array(self._parse_block(inputfile, count, float, "Beta Coefficients"))
            coeffs.shape = (self.nmo, self.nbasis)
            self.append_attribute("mocoeffs", coeffs)

        if line[0:21] == "Beta Orbital Energies":
            count = int(line.split()[-1])
            assert count == self.nmo

            energies = numpy.array(self._parse_block(inputfile, count, float, "Alpha MO Energies"))
            self.append_attribute("moenergies", energies)

        if line[0:11] == "Shell types":
            self.parse_aonames(line, inputfile)

        if line[0:19] == "Real atomic weights":
            count = int(line.split()[-1])
            assert count == self.natom

            atommasses = numpy.array(self._parse_block(inputfile, count, float, "Atomic Masses"))

            self.set_attribute("atommasses", atommasses)

        if line[0:16] == "Mulliken Charges":
            count = int(line.split()[-1])
            if not hasattr(self, "atomcharges"):
                self.atomcharges = {}
            self.atomcharges["mulliken"] = self._parse_block(
                inputfile, count, float, "Mulliken Charges"
            )

        if line[0:18] == "Cartesian Gradient":
            assert self.program == "Gaussian"
            self._parse_gradient(line, inputfile)

        if line[0:16] == "Cartesian Forces":
            assert self.program == "QChem"
            self._parse_gradient(line, inputfile)

        if line[0:13] == "Dipole Moment":
            assert self.program == "Gaussian"

        if line[0:20] == "QEq coupling tensors":
            assert self.program == "Gaussian"
            self.gaussian_has_qeq_coupling_tensors = True

        if line[0:14] == "Polarizability":
            polarizability = numpy.asarray(self._parse_block(inputfile, 6, float, "Polarizability"))
            self.append_attribute("polarizabilities", utils.block_to_matrix(polarizability))

        if line[0:25] == "Cartesian Force Constants":
            count = int(line.split()[-1])
            assert count == (3 * self.natom * (3 * self.natom + 1)) / 2

            hessian = numpy.array(self._parse_block(inputfile, count, float, "Hessian"))

            self.set_attribute("hessian", utils.block_to_matrix(hessian))

        if line[0:22] == "Number of Normal Modes":
            self.set_attribute("nmode", int(line.split()[-1]))

        if line[0:6] == "Vib-E2":
            count = int(line.split()[-1])
            le2 = self._parse_block(inputfile, count, float, "Vib-E2")
            assert hasattr(self, "nmode")
            nmode = self.nmode
            self.set_attribute("vibfreqs", le2[:nmode])
            le2 = le2[nmode:]
            self.set_attribute("vibrmasses", le2[:nmode])
            le2 = le2[nmode:]
            self.set_attribute("vibfconsts", le2[:nmode])
            le2 = le2[nmode:]
            self.set_attribute("vibirs", le2[:nmode])
            # The rest should be empty unless Raman or ROA were calculated.
            le2 = numpy.asarray(le2[nmode:])
            if numpy.any(le2[:nmode] >= 1.0e-20):
                self.set_attribute("vibramans", le2[:nmode])
                le2 = le2[nmode:]

        if line[0:9] == "Vib-Modes":
            count = int(line.split()[-1])
            vibdisps = numpy.asarray(self._parse_block(inputfile, count, float, "Vib-Modes"))
            # indices from fast to slow are [xyz, atom, mode]
            assert hasattr(self, "nmode")
            assert count == 3 * self.natom * self.nmode
            self.set_attribute("vibdisps", vibdisps.reshape(self.nmode, self.natom, 3))

        if line[0:13] == "ETran scalars":
            count = int(line.split()[-1])

            etscalars = self._parse_block(inputfile, count, int, "ET Scalars")

            # Set attribute: self.netroot (number of excited estates)
            self.netroot = etscalars[4]

        if line[0:10] == "ETran spin":
            count = int(line.split()[-1])

            etspin = self._parse_block(inputfile, count, int, "ET Spin")

            spin_labels = {0: "Singlet", 2: "Triplet", -1: "Unknown"}
            etsyms = []
            for i in etspin:
                if i in spin_labels:
                    etsyms.append(spin_labels[i])
                else:
                    etsyms.append(spin_labels[-1])

            # The extracted property does not contain the actual irrep label
            # (contrarily to that extracted from the Gaussian log)
            # After this, 'Etran sym' appears (and would need to be parsed),
            # but at least in Gaussian this contains only zeroes regardless of the irrep.

            self.set_attribute("etsyms", etsyms)

        if line[0:18] == "ETran state values":
            # This section is organized as follows:
            # ·First the properties of each excited state (up to net):
            # E, {muNx,muNy,muNz,muvelNx,muvelNy,muvelNz,mmagNx,mmagNy,mmagNz,unkX,unkY,unkZ,unkX,unkY,unkZ}_N=1,net
            # ·Then come 48 items (only if Freq is requested)
            # They were all 0.000 in G09, but get an actual value in G16
            # ·Then, the derivates of each property with respect to Cartesian coordiates only for target state (netroot)
            # For each Cartesian coordiate, all derivatives wrt to it are included:
            #  dE/dx1 dmux/dx1 dmuy/dx1 ... unkZ/dx1
            #  dE/dy1 dmux/dy1 dmuy/dy1 ... unkZ/dy1
            #  ...
            #  dE/dzN dmux/dzN dmuy/dzN ... unkZ/dzN
            # The number of items is therefore:
            ### 16*net (no Freq jobs)
            ### 16*net + 48 + 3*self.natom*16 (Freq jobs)
            count = int(line.split()[-1])
            if hasattr(self, "etsyms"):
                net = len(self.etsyms)
            else:
                net = 0  # This forces an AssertionError below
            assert count in [16 * net, 16 * net + 48 + 3 * self.natom * 16]

            etvalues = self._parse_block(inputfile, count, float, "ET Values")

            # ETr energies (1/cm)
            etenergies = [e_es - self.scfenergies[-1] for e_es in etvalues[0 : net * 16 : 16]]
            self.set_attribute("etenergies", etenergies)

            # ETr dipoles (length-gauge)
            etdips = []
            for k in range(1, 16 * net, 16):
                etdips.append(etvalues[k : k + 3])
            self.set_attribute("etdips", etdips)

            # Osc. Strength from Etr dipoles
            # oscs = 2/3 * Etr(au) * dip²(au)
            etoscs = [
                2.0 / 3.0 * e * numpy.linalg.norm(numpy.array(dip)) ** 2
                for e, dip in zip(etenergies, etdips)
            ]
            self.set_attribute("etoscs", etoscs)

            # ETr dipoles (velocity-gauge)
            etveldips = []
            for k in range(4, 16 * net, 16):
                etveldips.append(etvalues[k : k + 3])
            self.set_attribute("etveldips", etveldips)

            # ETr magnetic dipoles
            etmagdips = []
            for k in range(7, 16 * net, 16):
                etmagdips.append(etvalues[k : k + 3])
            self.set_attribute("etmagdips", etmagdips)

        if line[0:19] == "Excitation Energies":
            count = int(line.split()[-1])
            etenergies = self._parse_block(inputfile, count, float, "Excitation energies")
            self.set_attribute("etenergies", etenergies)

        if line[0:20] == "Oscillator Strengths":
            count = int(line.split()[-1])
            etoscs = self._parse_block(inputfile, count, float, "Oscillator Strengths")
            self.set_attribute("etoscs", etoscs)

        if line[0:11] == "Dipole_Data":
            assert self.program == "QChem"
            if hasattr(self, "moments"):
                self.set_attribute("moments", [])
            count = int(line.split()[-1])
            self.logger.info("The origin for multipole moments isn't printed, so assume zero")
            self.append_attribute("moments", [0.0, 0.0, 0.0])
            self.append_attribute(
                "moments", self._parse_block(inputfile, count, float, "Dipole moment")
            )

        if line[0:15] == "Quadrupole_Data":
            assert self.program == "QChem"
            assert hasattr(self, "moments")
            assert len(self.moments) == 2
            count = int(line.split()[-1])
            quadrupole_unsorted = self._parse_block(inputfile, count, float, "Quadrupole moment")
            quadrupole_sorted = list(
                zip(*sorted(zip(QCHEM_LABELS_QUADRUPOLE, quadrupole_unsorted), key=lambda x: x[0]))
            )[1]
            self.append_attribute("moments", quadrupole_sorted)

        if line[0:13] == "Octapole_Data":
            assert self.program == "QChem"
            assert hasattr(self, "moments")
            assert len(self.moments) == 3
            count = int(line.split()[-1])
            octupole_unsorted = self._parse_block(inputfile, count, float, "Octupole moment")
            octupole_sorted = list(
                zip(*sorted(zip(QCHEM_LABELS_OCTUPOLE, octupole_unsorted), key=lambda x: x[0]))
            )[1]
            self.append_attribute("moments", octupole_sorted)

        if line[0:17] == "Hexadecapole_Data":
            assert self.program == "QChem"
            assert hasattr(self, "moments")
            assert len(self.moments) == 4
            count = int(line.split()[-1])
            hexadecapole_unsorted = self._parse_block(
                inputfile, count, float, "Hexadecapole moment"
            )
            hexadecapole_sorted = list(
                zip(
                    *sorted(
                        zip(QCHEM_LABELS_HEXADECAPOLE, hexadecapole_unsorted), key=lambda x: x[0]
                    )
                )
            )[1]
            self.append_attribute("moments", hexadecapole_sorted)

        if line[0:16] == "Gaussian Version":
            assert self.program == "Gaussian"
            line = next(inputfile)
            self.metadata.update(gaussian_parse_version(line.strip()))

    def parse_aonames(self, line, inputfile):
        # e.g.: Shell types                                I   N=          28
        count = int(line.split()[-1])
        shell_types = self._parse_block(inputfile, count, int, "Atomic Orbital Names")

        # e.g.: Number of primitives per shell             I   N=          28
        next(inputfile)
        self._parse_block(inputfile, count, int, "Atomic Orbital Names")

        # e.g. Shell to atom map                          I   N=          28
        next(inputfile)
        shell_map = self._parse_block(inputfile, count, int, "Atomic Orbital Names")

        elements = (self.table.element[x] for x in self.atomnos)
        atom_labels = [f"{y}{x}" for x, y in enumerate(elements, 1)]

        # get orbitals for first atom and start aonames and atombasis lists
        atom = shell_map[0] - 1
        shell_offset = 0
        orbitals = _shell_to_orbitals(shell_types[0], shell_offset)
        aonames = [f"{atom_labels[atom]}_{x}" for x in orbitals]
        atombasis = [list(range(len(orbitals)))]

        # get rest
        for i in range(1, len(shell_types)):
            _type = shell_types[i]
            atom = shell_map[i] - 1
            shell_offset += 1
            basis_offset = (
                atombasis[-1][-1] + 1
            )  # atombasis is increasing numbers, so just grab last

            # if we've move to next atom, need to update offset of shells (e.g. start at 1S)
            # and start new list for atom basis
            if atom != shell_map[i - 1] - 1:
                shell_offset = 0
                atombasis.append([])

            # determine if we've changed shell type (e.g. from S to P)
            if _type != shell_types[i - 1]:
                shell_offset = 0

            orbitals = _shell_to_orbitals(_type, shell_offset)
            aonames.extend([f"{atom_labels[atom]}_{x}" for x in orbitals])
            atombasis[-1].extend(list(range(basis_offset, basis_offset + len(orbitals))))

        assert len(aonames) == self.nbasis, (
            f"Length of aonames != nbasis: {len(aonames)} != {self.nbasis}"
        )
        self.set_attribute("aonames", aonames)

        assert len(atombasis) == self.natom, (
            f"Length of atombasis != natom: {len(atombasis)} != {self.natom}"
        )
        self.set_attribute("atombasis", atombasis)

    def after_parsing(self) -> None:
        """Correct data or do parser-specific validation after parsing is finished."""
        super().after_parsing()

        if hasattr(self, "program"):
            unknown_jobtype = False
            self.metadata["package"] = f"FChk[{self.program}]"
            if self.program == "Gaussian":
                unknown_jobtype = self.jobtype not in ("sp", "freq", "fopt", "scan")
                if self.jobtype == "sp":
                    # The calculation will not produce an fchk file at all if
                    # the SCF doesn't converge.
                    self.success = True
                elif self.jobtype == "fopt":
                    # For Gaussian 03; in 09 and newer it is always present,
                    # and in 16 and newer it isn't necessary.  For 09 there is
                    # no way to differentiate between success and failure.
                    if self.gaussian_03_or_earlier:
                        assert self.success is None
                        self.success = self.gaussian_has_qeq_coupling_tensors
                    opt_converged = self.success
                    self._set_optstatus_and_optdone_from_atomcoords(opt_converged, False)
            elif self.program == "Psi4":
                unknown_jobtype = self.jobtype not in ("sp", "force")
                # The calculation will halt before making it to the fchk(wfn,
                # ...) call in the input file if something didn't converge, so
                # the file's existence always signifies success.
                self.success = True
            elif self.program == "QChem":
                unknown_jobtype = self.jobtype not in ("sp", "freq", "force", "fopt")
                # Q-Chem will write the fchk file no matter what happens to the
                # calculation, however the absence of certain attributes can be used
                # to determine if the calculation ran properly.
                if not hasattr(self, "moenergies"):
                    self.success = False
                if self.jobtype == "fopt":
                    opt_converged = len(self.atomcoords) == len(self.grads)
                    self._set_optstatus_and_optdone_from_atomcoords(opt_converged, True)
            else:
                self.logger.info("Unknown originating program for fchk file: %s", self.program)
            if unknown_jobtype:
                self.logger.info("Unknown job type for fchk file: %s", self.jobtype)
        else:
            self.logger.info("Couldn't determine originating program for fchk file")

        # If restricted calculation, need to remove beta homo
        if hasattr(self, "moenergies") and hasattr(self, "homos"):
            if len(self.moenergies) == len(self.homos) - 1:
                self.homos.pop()

        if self.success is not None:
            self.metadata["success"] = self.success

    def _parse_block(
        self, inputfile: "FileWrapper", count: int, type: Type[T], msg: str
    ) -> List[T]:
        elements = []
        while len(elements) < count:
            self.updateprogress(inputfile, msg, self.fupdate)
            line = next(inputfile)
            elements.extend([type(x) for x in line.split()])
        return elements

    def _parse_gradient(self, line: str, inputfile: "FileWrapper") -> None:
        count = int(line.split()[-1])
        assert count == self.natom * 3
        gradient = numpy.array(self._parse_block(inputfile, count, float, "Gradient"))
        gradient.shape = (self.natom, 3)
        self.append_attribute("grads", gradient)

    def _set_optstatus_and_optdone_from_atomcoords(
        self, opt_converged: Optional[bool], can_set_opt_new: bool
    ) -> None:
        """For geometry optimizations, use the length of atomcoords and an
        external trigger of whether or not the optimization converged to
        determine optstatus and optdone.
        """
        optstatus = [data.ccData.OPT_UNKNOWN for _ in range(len(self.atomcoords))]
        if optstatus:
            # For Gaussian, which only prints the final geometry, it is not
            # possible to say anything about whether or not the printed
            # geometry is the only one, in which case it would be new.
            if can_set_opt_new:
                optstatus[0] += data.ccData.OPT_NEW
            if opt_converged is not None:
                if opt_converged:
                    optstatus[-1] += data.ccData.OPT_DONE
                    self.append_attribute("optdone", len(self.atomcoords))
                else:
                    optstatus[-1] += data.ccData.OPT_UNCONVERGED
                    self.set_attribute("optdone", [])
            self.set_attribute("optstatus", optstatus)


# These are the orderings of the named multipole moments as presented by
# Q-Chem in the main output file; they are printed in the same order in the
# formatted checkpoint file and are used to then sort the moments into
# lexicographic (cclib) order.
QCHEM_LABELS_QUADRUPOLE = ["XX", "XY", "YY", "XZ", "YZ", "ZZ"]
QCHEM_LABELS_OCTUPOLE = ["XXX", "XXY", "XYY", "YYY", "XXZ", "XYZ", "YYZ", "XZZ", "YZZ", "ZZZ"]
QCHEM_LABELS_HEXADECAPOLE = [
    "XXXX",
    "XXXY",
    "XXYY",
    "XYYY",
    "YYYY",
    "XXXZ",
    "XXYZ",
    "XYYZ",
    "YYYZ",
    "XXZZ",
    "XYZZ",
    "YYZZ",
    "XZZZ",
    "YZZZ",
    "ZZZZ",
]
